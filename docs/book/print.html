<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dotlanth Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Dotlanth Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/synerthink-organization/dotVM" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-dotlanth"><a class="header" href="#welcome-to-dotlanth">Welcome to Dotlanth</a></h1>
<p>Welcome to the comprehensive documentation for Dotlanth, a next-generation virtual machine solution designed for high-performance parallel contract execution and state management.</p>
<h2 id="project-overview"><a class="header" href="#project-overview">Project Overview</a></h2>
<p>Dotlanth consists of two main components that work together to provide a complete virtual machine and database solution:</p>
<h3 id="dotvm-virtual-machine"><a class="header" href="#dotvm-virtual-machine">DOTVM (Virtual Machine)</a></h3>
<p>DOTVM is a highly efficient virtual machine designed to execute smart contracts with advanced parallelization capabilities. It supports multiple architectures (32/64/128/256/512-bit) and provides robust security features.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Multi-architecture support</strong>: 32, 64, 128, 256, and 512-bit architectures</li>
<li><strong>ParaContracts system</strong>: Advanced parallel execution capabilities</li>
<li><strong>Comprehensive instruction set</strong>: Arithmetic, control flow, memory, crypto, SIMD, and more</li>
<li><strong>Rust to DotVM transpilation</strong>: Complete toolchain from Rust source to bytecode</li>
<li><strong>Advanced security and isolation</strong>: Memory protection and secure execution</li>
<li><strong>Cross-platform compatibility</strong>: Runs on multiple operating systems</li>
<li><strong>Integrated state management</strong>: Seamless integration with DOTDB</li>
</ul>
<p><strong>CLI Tools:</strong></p>
<ul>
<li><code>dotvm transpile</code>: Transpile Rust code to DotVM bytecode</li>
<li><code>dotvm run</code>: Execute DotVM bytecode with debugging capabilities</li>
</ul>
<h3 id="dotdb-document-database"><a class="header" href="#dotdb-document-database">DOTDB (Document Database)</a></h3>
<p>DOTDB is a custom-built document database designed to work seamlessly with DOTVM. It provides efficient state management and storage capabilities optimized for blockchain and high-performance applications.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Document-based storage</strong>: JSON document collections with efficient indexing</li>
<li><strong>Custom storage engine</strong>: Optimized for high-performance operations</li>
<li><strong>Advanced state management</strong>: MVCC (Multi-Version Concurrency Control)</li>
<li><strong>Efficient indexing system</strong>: B+ trees, hash indices, and composite indices</li>
<li><strong>Memory management</strong>: Advanced allocators and caching systems</li>
<li><strong>Query optimization</strong>: Cost-based query planner and optimizer</li>
</ul>
<p><strong>CLI Tools:</strong></p>
<ul>
<li><code>dotdb put/get/update/delete</code>: Basic document operations</li>
<li><code>dotdb collections</code>: Collection management</li>
<li><code>dotdb find</code>: Query documents by field values</li>
</ul>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<pre><code>+-------------------+    +-------------------+
|   Rust Code       |---&gt;|  DotVM Bytecode   |
+-------------------+    +-------------------+
         |                       |
         v                       v
+-------------------+    +-------------------+
| Transpiler CLI    |    |  Executor CLI     |
+-------------------+    +-------------------+
                               |
                               v
                    +-------------------+
                    |     DOTDB         |
                    | (State Storage)   |
                    +-------------------+
</code></pre>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<ol>
<li><strong>Installation</strong>: <a href="getting-started/installation.html">Get started with installation</a></li>
<li><strong>CLI Tools</strong>: Learn to use <a href="cli/dotvm.html">DotVM CLI</a> and <a href="cli/dotdb.html">DotDB CLI</a></li>
<li><strong>First Program</strong>: Follow the <a href="getting-started/quickstart.html">quickstart guide</a></li>
<li><strong>Development</strong>: Set up your <a href="getting-started/development-setup.html">development environment</a></li>
</ol>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><a href="getting-started/installation.html">Installation Guide</a></li>
<li><a href="cli/dotvm.html">DotVM CLI Reference</a></li>
<li><a href="cli/dotdb.html">DotDB CLI Reference</a></li>
<li><a href="dotvm/architecture/core.html">Architecture Overview</a></li>
<li><a href="contributing/guidelines.html">Contributing Guidelines</a></li>
</ul>
<h2 id="support-and-community"><a class="header" href="#support-and-community">Support and Community</a></h2>
<ul>
<li><strong>GitHub Repository</strong>: <a href="https://github.com/synerthink-organization/dotVM">synerthink-organization/dotVM</a></li>
<li><strong>Issues</strong>: Report bugs and request features on GitHub</li>
<li><strong>Documentation</strong>: Comprehensive guides and API references</li>
<li><strong>License</strong>: GNU Affero General Public License v3.0</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-guide"><a class="header" href="#installation-guide">Installation Guide</a></h1>
<p>This guide will help you set up DOTVM and DOTDB on your system. Choose the installation method that best suits your needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-guide"><a class="header" href="#quickstart-guide">Quickstart Guide</a></h1>
<p>This guide will get you up and running with Dotlanth in just a few minutes. You’ll learn how to transpile Rust code to DotVM bytecode and execute it, as well as how to use the DotDB document database.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Make sure you have completed the <a href="getting-started/installation.html">installation</a> process and have both <code>dotvm</code> and <code>dotdb</code> CLI tools available.</p>
<h2 id="your-first-dotvm-program"><a class="header" href="#your-first-dotvm-program">Your First DotVM Program</a></h2>
<p>Let’s create a simple “Hello, World!” program and run it through the complete DotVM pipeline.</p>
<h3 id="step-1-create-a-rust-program"><a class="header" href="#step-1-create-a-rust-program">Step 1: Create a Rust Program</a></h3>
<p>Create a new file called <code>hello.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, DotVM!");
    let result = 40 + 2;
    println!("The answer is: {}", result);
}</code></pre></pre>
<h3 id="step-2-transpile-to-dotvm-bytecode"><a class="header" href="#step-2-transpile-to-dotvm-bytecode">Step 2: Transpile to DotVM Bytecode</a></h3>
<p>Use the DotVM CLI to transpile your Rust code to bytecode:</p>
<pre><code class="language-bash">dotvm transpile -i hello.rs -o hello.dotvm --verbose
</code></pre>
<p>You should see output similar to:</p>
<pre><code>Loading Rust source: hello.rs
Compiling Rust to WebAssembly...
Parsing WebAssembly module...
Translating to DotVM bytecode...
Optimizing for arch64 architecture...
Writing bytecode to: hello.dotvm
Transpilation completed successfully!
</code></pre>
<h3 id="step-3-execute-the-bytecode"><a class="header" href="#step-3-execute-the-bytecode">Step 3: Execute the Bytecode</a></h3>
<p>Run your DotVM bytecode:</p>
<pre><code class="language-bash">dotvm run hello.dotvm --verbose
</code></pre>
<p>Expected output:</p>
<pre><code>Loading bytecode from: hello.dotvm
Bytecode loaded in 1.2ms
Starting execution...
Hello, DotVM!
The answer is: 42
Execution completed!
Instructions executed: 156
Execution time: 0.8ms
Total time: 2.0ms
</code></pre>
<p>Congratulations! You’ve successfully created, transpiled, and executed your first DotVM program.</p>
<h2 id="your-first-dotdb-operations"><a class="header" href="#your-first-dotdb-operations">Your First DotDB Operations</a></h2>
<p>Now let’s explore the document database capabilities.</p>
<h3 id="step-1-create-a-collection"><a class="header" href="#step-1-create-a-collection">Step 1: Create a Collection</a></h3>
<p>Create a collection to store user data:</p>
<pre><code class="language-bash">dotdb create-collection users
</code></pre>
<h3 id="step-2-insert-documents"><a class="header" href="#step-2-insert-documents">Step 2: Insert Documents</a></h3>
<p>Add some user documents:</p>
<pre><code class="language-bash"># Insert first user
dotdb put users '{
  "name": "Alice Johnson",
  "email": "alice@example.com",
  "age": 30,
  "role": "developer"
}'

# Insert second user
dotdb put users '{
  "name": "Bob Smith", 
  "email": "bob@example.com",
  "age": 25,
  "role": "designer"
}'

# Insert third user
dotdb put users '{
  "name": "Charlie Brown",
  "email": "charlie@example.com", 
  "age": 35,
  "role": "manager"
}'
</code></pre>
<h3 id="step-3-query-the-database"><a class="header" href="#step-3-query-the-database">Step 3: Query the Database</a></h3>
<p>List all collections:</p>
<pre><code class="language-bash">dotdb collections
</code></pre>
<p>List all user IDs:</p>
<pre><code class="language-bash">dotdb list users
</code></pre>
<p>Count users:</p>
<pre><code class="language-bash">dotdb count users
</code></pre>
<p>Find users by role:</p>
<pre><code class="language-bash">dotdb find users role '"developer"'
</code></pre>
<h3 id="step-4-retrieve-and-update-documents"><a class="header" href="#step-4-retrieve-and-update-documents">Step 4: Retrieve and Update Documents</a></h3>
<p>Get a specific user (use an ID from the list command):</p>
<pre><code class="language-bash">dotdb get users &lt;user_id&gt;
</code></pre>
<p>Update a user’s information:</p>
<pre><code class="language-bash">dotdb update users &lt;user_id&gt; '{
  "name": "Alice Johnson",
  "email": "alice.johnson@example.com",
  "age": 31,
  "role": "senior_developer"
}'
</code></pre>
<h2 id="advanced-example-calculator-program"><a class="header" href="#advanced-example-calculator-program">Advanced Example: Calculator Program</a></h2>
<p>Let’s create a more complex program that demonstrates DotVM’s capabilities.</p>
<h3 id="step-1-create-the-calculator"><a class="header" href="#step-1-create-the-calculator">Step 1: Create the Calculator</a></h3>
<p>Create <code>calculator.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn multiply(a: i32, b: i32) -&gt; i32 {
    a * b
}

fn factorial(n: i32) -&gt; i32 {
    if n &lt;= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

fn main() {
    println!("DotVM Calculator Demo");
    
    let x = 10;
    let y = 5;
    
    println!("{} + {} = {}", x, y, add(x, y));
    println!("{} * {} = {}", x, y, multiply(x, y));
    println!("{}! = {}", y, factorial(y));
    
    // Demonstrate loops
    println!("Counting to 5:");
    for i in 1..=5 {
        println!("  {}", i);
    }
}</code></pre></pre>
<h3 id="step-2-transpile-with-different-architectures"><a class="header" href="#step-2-transpile-with-different-architectures">Step 2: Transpile with Different Architectures</a></h3>
<p>Try different VM architectures:</p>
<pre><code class="language-bash"># 64-bit architecture (default)
dotvm transpile -i calculator.rs -o calculator_64.dotvm -a arch64

# 256-bit architecture
dotvm transpile -i calculator.rs -o calculator_256.dotvm -a arch256

# With debug information
dotvm transpile -i calculator.rs -o calculator_debug.dotvm --debug --verbose
</code></pre>
<h3 id="step-3-execute-with-debug-mode"><a class="header" href="#step-3-execute-with-debug-mode">Step 3: Execute with Debug Mode</a></h3>
<p>Run with debug information to see instruction execution:</p>
<pre><code class="language-bash">dotvm run calculator_debug.dotvm --debug
</code></pre>
<h2 id="working-with-both-systems"><a class="header" href="#working-with-both-systems">Working with Both Systems</a></h2>
<p>DotVM and DotDB are designed to work together. Here’s an example of how they might be used in a real application:</p>
<h3 id="step-1-create-application-data"><a class="header" href="#step-1-create-application-data">Step 1: Create Application Data</a></h3>
<p>Set up collections for an application:</p>
<pre><code class="language-bash"># Create collections
dotdb create-collection config
dotdb create-collection logs
dotdb create-collection results

# Add configuration
dotdb put config '{
  "app_name": "DotVM Calculator",
  "version": "1.0.0",
  "max_calculations": 1000
}'

# Add some initial data
dotdb put results '{
  "operation": "factorial",
  "input": 5,
  "result": 120,
  "timestamp": "2025-01-01T12:00:00Z"
}'
</code></pre>
<h3 id="step-2-create-a-data-aware-program"><a class="header" href="#step-2-create-a-data-aware-program">Step 2: Create a Data-Aware Program</a></h3>
<p>Create <code>data_app.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Data-aware DotVM application");
    
    // In a real application, this would use DotDB opcodes
    // to read configuration and store results
    
    let calculations = vec![
        ("add", 10, 5, 15),
        ("multiply", 10, 5, 50),
        ("subtract", 10, 5, 5),
    ];
    
    println!("Performing calculations:");
    for (op, a, b, result) in calculations {
        println!("{} {} {} = {}", a, op, b, result);
    }
    
    println!("Results would be stored in DotDB");
}</code></pre></pre>
<h3 id="step-3-execute-and-verify"><a class="header" href="#step-3-execute-and-verify">Step 3: Execute and Verify</a></h3>
<pre><code class="language-bash"># Transpile and run
dotvm transpile -i data_app.rs -o data_app.dotvm
dotvm run data_app.dotvm

# Check database state
dotdb count results
dotdb list results
</code></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<p>Test the performance characteristics of your programs:</p>
<h3 id="step-1-create-a-performance-test"><a class="header" href="#step-1-create-a-performance-test">Step 1: Create a Performance Test</a></h3>
<p>Create <code>performance_test.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn fibonacci(n: u32) -&gt; u64 {
    match n {
        0 =&gt; 0,
        1 =&gt; 1,
        _ =&gt; fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn main() {
    println!("Performance test starting...");
    
    let test_values = [10, 15, 20, 25];
    
    for &amp;n in &amp;test_values {
        let result = fibonacci(n);
        println!("fibonacci({}) = {}", n, result);
    }
    
    println!("Performance test completed!");
}</code></pre></pre>
<h3 id="step-2-run-performance-tests"><a class="header" href="#step-2-run-performance-tests">Step 2: Run Performance Tests</a></h3>
<pre><code class="language-bash"># Transpile with maximum optimization
dotvm transpile -i performance_test.rs -o perf_test.dotvm --opt-level 3

# Run with timing information
dotvm run perf_test.dotvm --verbose

# Compare different architectures
dotvm transpile -i performance_test.rs -o perf_test_256.dotvm -a arch256 --opt-level 3
dotvm run perf_test_256.dotvm --verbose
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you’ve completed the quickstart guide, you can:</p>
<ol>
<li><strong>Explore CLI Features</strong>: Learn more about <a href="getting-started/../cli/dotvm.html">DotVM CLI</a> and <a href="getting-started/../cli/dotdb.html">DotDB CLI</a></li>
<li><strong>Understand Architecture</strong>: Read about <a href="getting-started/../dotvm/architecture/vm-architectures.html">VM architectures</a> and <a href="getting-started/../dotvm/architecture/instruction-set.html">instruction sets</a></li>
<li><strong>Advanced Usage</strong>: Check out <a href="getting-started/../dotvm/usage/advanced-features.html">advanced DotVM features</a></li>
<li><strong>Development Setup</strong>: Set up a <a href="getting-started/development-setup.html">development environment</a> for contributing</li>
<li><strong>API Reference</strong>: Explore the <a href="getting-started/../dotvm/api/core.html">Core API</a> documentation</li>
</ol>
<h2 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h2>
<h3 id="transpilation-fails"><a class="header" href="#transpilation-fails">Transpilation Fails</a></h3>
<ul>
<li>Ensure your Rust code compiles with <code>rustc</code></li>
<li>Check that all dependencies are available</li>
<li>Try with <code>--verbose</code> flag for more information</li>
</ul>
<h3 id="execution-errors"><a class="header" href="#execution-errors">Execution Errors</a></h3>
<ul>
<li>Verify the bytecode file exists and is not corrupted</li>
<li>Check architecture compatibility</li>
<li>Use <code>--debug</code> mode to see detailed execution information</li>
</ul>
<h3 id="database-operations-fail"><a class="header" href="#database-operations-fail">Database Operations Fail</a></h3>
<ul>
<li>Ensure collections exist before inserting documents</li>
<li>Verify JSON syntax in document content</li>
<li>Check available disk space and permissions</li>
</ul>
<h3 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h3>
<ul>
<li>Try different optimization levels (<code>--opt-level 0-3</code>)</li>
<li>Test different VM architectures</li>
<li>Use <code>--verbose</code> to identify bottlenecks</li>
</ul>
<p>For more detailed troubleshooting, see the <a href="getting-started/../guides/troubleshooting.html">troubleshooting guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h1>
<p>This guide will help you set up a complete development environment for contributing to Dotlanth, including tools, workflows, and best practices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dotvm-cli-reference"><a class="header" href="#dotvm-cli-reference">DotVM CLI Reference</a></h1>
<p>The DotVM CLI provides tools for transpiling Rust code to DotVM bytecode and executing bytecode programs.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>The DotVM CLI is built as part of the workspace. To build and install:</p>
<pre><code class="language-bash">cargo build --release --bin dotvm
# The binary will be available at target/release/dotvm
</code></pre>
<h2 id="commands-overview"><a class="header" href="#commands-overview">Commands Overview</a></h2>
<p>The DotVM CLI provides two main commands:</p>
<ul>
<li><code>transpile</code>: Transpile Rust code to DotVM bytecode</li>
<li><code>run</code>: Execute DotVM bytecode files</li>
</ul>
<h2 id="global-options"><a class="header" href="#global-options">Global Options</a></h2>
<pre><code>dotvm [OPTIONS] &lt;COMMAND&gt;

Options:
  -h, --help     Print help
  -V, --version  Print version
</code></pre>
<h2 id="transpile-command"><a class="header" href="#transpile-command">Transpile Command</a></h2>
<p>Transpile Rust source code to DotVM bytecode through the Rust → WebAssembly → DotVM pipeline.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-bash">dotvm transpile [OPTIONS] --input &lt;INPUT&gt; --output &lt;OUTPUT&gt;
</code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>--input &lt;INPUT&gt;</code></td><td><code>-i</code></td><td>Input Rust source file or project directory</td><td>Required</td></tr>
<tr><td><code>--output &lt;OUTPUT&gt;</code></td><td><code>-o</code></td><td>Output DotVM bytecode file</td><td>Required</td></tr>
<tr><td><code>--architecture &lt;ARCH&gt;</code></td><td><code>-a</code></td><td>Target VM architecture</td><td><code>arch64</code></td></tr>
<tr><td><code>--opt-level &lt;LEVEL&gt;</code></td><td></td><td>Optimization level (0-3)</td><td><code>2</code></td></tr>
<tr><td><code>--debug</code></td><td></td><td>Enable debug information</td><td><code>false</code></td></tr>
<tr><td><code>--verbose</code></td><td><code>-v</code></td><td>Verbose output</td><td><code>false</code></td></tr>
<tr><td><code>--keep-intermediate</code></td><td></td><td>Keep intermediate files (Wasm)</td><td><code>false</code></td></tr>
<tr><td><code>--target-dir &lt;DIR&gt;</code></td><td></td><td>Custom target directory for Rust compilation</td><td>None</td></tr>
</tbody></table>
</div>
<h3 id="architecture-options"><a class="header" href="#architecture-options">Architecture Options</a></h3>
<ul>
<li><code>arch64</code>: 64-bit architecture (default)</li>
<li><code>arch128</code>: 128-bit architecture</li>
<li><code>arch256</code>: 256-bit architecture</li>
<li><code>arch512</code>: 512-bit architecture</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p><strong>Basic transpilation:</strong></p>
<pre><code class="language-bash">dotvm transpile -i src/main.rs -o program.dotvm
</code></pre>
<p><strong>With specific architecture:</strong></p>
<pre><code class="language-bash">dotvm transpile -i src/main.rs -o program.dotvm -a arch256
</code></pre>
<p><strong>Debug build with verbose output:</strong></p>
<pre><code class="language-bash">dotvm transpile -i src/main.rs -o program.dotvm --debug --verbose
</code></pre>
<p><strong>Keep intermediate files:</strong></p>
<pre><code class="language-bash">dotvm transpile -i src/main.rs -o program.dotvm --keep-intermediate
</code></pre>
<h3 id="transpilation-pipeline"><a class="header" href="#transpilation-pipeline">Transpilation Pipeline</a></h3>
<p>The transpilation process follows these steps:</p>
<ol>
<li><strong>Rust Compilation</strong>: Compile Rust source to WebAssembly</li>
<li><strong>Wasm Parsing</strong>: Parse WebAssembly module</li>
<li><strong>DotVM Translation</strong>: Translate Wasm instructions to DotVM bytecode</li>
<li><strong>Optimization</strong>: Apply architecture-specific optimizations</li>
<li><strong>Bytecode Generation</strong>: Generate final DotVM bytecode file</li>
</ol>
<h2 id="run-command"><a class="header" href="#run-command">Run Command</a></h2>
<p>Execute DotVM bytecode files with debugging and profiling capabilities.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre><code class="language-bash">dotvm run [OPTIONS] &lt;BYTECODE_FILE&gt;
</code></pre>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>&lt;BYTECODE_FILE&gt;</code></td><td></td><td>Path to the bytecode file to execute</td><td>Required</td></tr>
<tr><td><code>--debug</code></td><td><code>-d</code></td><td>Enable debug mode (shows instruction execution)</td><td><code>false</code></td></tr>
<tr><td><code>--step</code></td><td><code>-s</code></td><td>Enable step mode (pause after each instruction)</td><td><code>false</code></td></tr>
<tr><td><code>--max-instructions &lt;NUM&gt;</code></td><td></td><td>Maximum number of instructions to execute</td><td><code>1000000</code></td></tr>
<tr><td><code>--verbose</code></td><td><code>-v</code></td><td>Verbose output</td><td><code>false</code></td></tr>
</tbody></table>
</div>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<p><strong>Basic execution:</strong></p>
<pre><code class="language-bash">dotvm run program.dotvm
</code></pre>
<p><strong>Debug execution:</strong></p>
<pre><code class="language-bash">dotvm run program.dotvm --debug
</code></pre>
<p><strong>Step-by-step execution:</strong></p>
<pre><code class="language-bash">dotvm run program.dotvm --step
</code></pre>
<p><strong>Verbose execution with custom instruction limit:</strong></p>
<pre><code class="language-bash">dotvm run program.dotvm --verbose --max-instructions 500000
</code></pre>
<h3 id="debug-mode"><a class="header" href="#debug-mode">Debug Mode</a></h3>
<p>When <code>--debug</code> is enabled, the executor will:</p>
<ul>
<li>Show each instruction as it’s executed</li>
<li>Display stack contents after each operation</li>
<li>Show memory access patterns</li>
<li>Report execution statistics</li>
</ul>
<h3 id="step-mode"><a class="header" href="#step-mode">Step Mode</a></h3>
<p>When <code>--step</code> is enabled, the executor will:</p>
<ul>
<li>Pause after each instruction</li>
<li>Wait for user input to continue</li>
<li>Allow inspection of VM state</li>
<li>Provide interactive debugging capabilities</li>
</ul>
<h3 id="output-information"><a class="header" href="#output-information">Output Information</a></h3>
<p>The run command provides detailed execution information:</p>
<pre><code>Execution completed!
Instructions executed: 1234
Execution time: 15.2ms
Total time: 18.7ms
Final stack size: 1
Final stack contents:
  [0]: 42
Program counter: 1234
Halted: true
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The CLI provides detailed error messages for common issues:</p>
<h3 id="transpilation-errors"><a class="header" href="#transpilation-errors">Transpilation Errors</a></h3>
<ul>
<li><strong>File not found</strong>: Check input file path</li>
<li><strong>Compilation failed</strong>: Review Rust compilation errors</li>
<li><strong>Wasm parsing failed</strong>: Ensure valid Rust code</li>
<li><strong>Translation failed</strong>: Check for unsupported features</li>
</ul>
<h3 id="execution-errors-1"><a class="header" href="#execution-errors-1">Execution Errors</a></h3>
<ul>
<li><strong>Invalid bytecode</strong>: File may be corrupted or wrong format</li>
<li><strong>Execution timeout</strong>: Increase <code>--max-instructions</code> limit</li>
<li><strong>Memory errors</strong>: Check for stack overflow or invalid memory access</li>
<li><strong>Architecture mismatch</strong>: Ensure bytecode matches VM architecture</li>
</ul>
<h2 id="integration-with-dotdb"><a class="header" href="#integration-with-dotdb">Integration with DOTDB</a></h2>
<p>The DotVM executor automatically integrates with DOTDB for state management:</p>
<ul>
<li>Database operations are available through DB opcodes</li>
<li>State persistence across executions</li>
<li>Transaction support for atomic operations</li>
<li>Query capabilities for complex data operations</li>
</ul>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<ol>
<li><strong>Use appropriate architecture</strong>: Match architecture to your data size requirements</li>
<li><strong>Optimize compilation</strong>: Use higher optimization levels for production</li>
<li><strong>Profile execution</strong>: Use debug mode to identify bottlenecks</li>
<li><strong>Batch operations</strong>: Group database operations for better performance</li>
</ol>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="complete-workflow"><a class="header" href="#complete-workflow">Complete Workflow</a></h3>
<ol>
<li><strong>Create a simple Rust program:</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust">// src/main.rs
fn main() {
    let result = 40 + 2;
    println!("The answer is: {}", result);
}</code></pre></pre>
<ol start="2">
<li><strong>Transpile to DotVM bytecode:</strong></li>
</ol>
<pre><code class="language-bash">dotvm transpile -i src/main.rs -o answer.dotvm --verbose
</code></pre>
<ol start="3">
<li><strong>Execute the bytecode:</strong></li>
</ol>
<pre><code class="language-bash">dotvm run answer.dotvm --debug
</code></pre>
<h3 id="advanced-example"><a class="header" href="#advanced-example">Advanced Example</a></h3>
<ol>
<li><strong>Transpile with optimizations:</strong></li>
</ol>
<pre><code class="language-bash">dotvm transpile \
  -i complex_program.rs \
  -o optimized.dotvm \
  -a arch256 \
  --opt-level 3 \
  --debug
</code></pre>
<ol start="2">
<li><strong>Execute with profiling:</strong></li>
</ol>
<pre><code class="language-bash">dotvm run optimized.dotvm --verbose --max-instructions 10000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dotdb-cli-reference"><a class="header" href="#dotdb-cli-reference">DotDB CLI Reference</a></h1>
<p>The DotDB CLI provides a command-line interface for interacting with the DotDB document database, allowing you to manage collections and documents efficiently.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>The DotDB CLI is built as part of the workspace. To build and install:</p>
<pre><code class="language-bash">cargo build --release --bin dotdb
# The binary will be available at target/release/dotdb
</code></pre>
<h2 id="commands-overview-1"><a class="header" href="#commands-overview-1">Commands Overview</a></h2>
<p>The DotDB CLI provides comprehensive document and collection management:</p>
<ul>
<li><code>put</code>: Insert a JSON document into a collection</li>
<li><code>get</code>: Retrieve a document by ID</li>
<li><code>update</code>: Update an existing document</li>
<li><code>delete</code>: Remove a document by ID</li>
<li><code>list</code>: List all document IDs in a collection</li>
<li><code>collections</code>: List all collections</li>
<li><code>create-collection</code>: Create a new collection</li>
<li><code>delete-collection</code>: Remove a collection and all its documents</li>
<li><code>count</code>: Count documents in a collection</li>
<li><code>find</code>: Find documents by field value</li>
</ul>
<h2 id="global-options-1"><a class="header" href="#global-options-1">Global Options</a></h2>
<pre><code>dotdb [OPTIONS] &lt;COMMAND&gt;

Options:
  -h, --help     Print help
  -V, --version  Print version
</code></pre>
<h2 id="document-operations"><a class="header" href="#document-operations">Document Operations</a></h2>
<h3 id="put-command"><a class="header" href="#put-command">Put Command</a></h3>
<p>Insert a JSON document into a collection.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb put &lt;COLLECTION&gt; &lt;JSON&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;COLLECTION&gt;</code>: Collection name</li>
<li><code>&lt;JSON&gt;</code>: JSON document content</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Insert a simple document
dotdb put users '{"name": "Alice", "age": 30, "email": "alice@example.com"}'

# Insert a complex document
dotdb put products '{
  "name": "Laptop",
  "price": 999.99,
  "specs": {
    "cpu": "Intel i7",
    "ram": "16GB",
    "storage": "512GB SSD"
  },
  "tags": ["electronics", "computers"]
}'
</code></pre>
<h3 id="get-command"><a class="header" href="#get-command">Get Command</a></h3>
<p>Retrieve a document by its ID.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb get &lt;COLLECTION&gt; &lt;ID&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;COLLECTION&gt;</code>: Collection name</li>
<li><code>&lt;ID&gt;</code>: Document ID</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Get a document by ID
dotdb get users user_123

# Get a product document
dotdb get products prod_456
</code></pre>
<h3 id="update-command"><a class="header" href="#update-command">Update Command</a></h3>
<p>Update an existing document by ID.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb update &lt;COLLECTION&gt; &lt;ID&gt; &lt;JSON&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;COLLECTION&gt;</code>: Collection name</li>
<li><code>&lt;ID&gt;</code>: Document ID</li>
<li><code>&lt;JSON&gt;</code>: New JSON document content</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Update user information
dotdb update users user_123 '{"name": "Alice Smith", "age": 31, "email": "alice.smith@example.com"}'

# Update product price
dotdb update products prod_456 '{
  "name": "Laptop",
  "price": 899.99,
  "specs": {
    "cpu": "Intel i7",
    "ram": "16GB", 
    "storage": "512GB SSD"
  }
}'
</code></pre>
<h3 id="delete-command"><a class="header" href="#delete-command">Delete Command</a></h3>
<p>Remove a document by ID.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb delete &lt;COLLECTION&gt; &lt;ID&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;COLLECTION&gt;</code>: Collection name</li>
<li><code>&lt;ID&gt;</code>: Document ID</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Delete a user
dotdb delete users user_123

# Delete a product
dotdb delete products prod_456
</code></pre>
<h3 id="list-command"><a class="header" href="#list-command">List Command</a></h3>
<p>List all document IDs in a collection.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb list &lt;COLLECTION&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;COLLECTION&gt;</code>: Collection name</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># List all user IDs
dotdb list users

# List all product IDs
dotdb list products
</code></pre>
<h3 id="find-command"><a class="header" href="#find-command">Find Command</a></h3>
<p>Find documents by field value.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb find &lt;COLLECTION&gt; &lt;FIELD&gt; &lt;VALUE&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;COLLECTION&gt;</code>: Collection name</li>
<li><code>&lt;FIELD&gt;</code>: Field name to search</li>
<li><code>&lt;VALUE&gt;</code>: Field value (JSON format)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Find users by age
dotdb find users age 30

# Find products by name
dotdb find products name '"Laptop"'

# Find users by email
dotdb find users email '"alice@example.com"'

# Find products by price range (requires JSON value)
dotdb find products price 999.99
</code></pre>
<h2 id="collection-management"><a class="header" href="#collection-management">Collection Management</a></h2>
<h3 id="collections-command"><a class="header" href="#collections-command">Collections Command</a></h3>
<p>List all collections in the database.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb collections
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">dotdb collections
# Output:
# Available collections:
# - users
# - products
# - orders
</code></pre>
<h3 id="create-collection-command"><a class="header" href="#create-collection-command">Create Collection Command</a></h3>
<p>Create a new collection.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb create-collection &lt;COLLECTION&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;COLLECTION&gt;</code>: Collection name</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Create a users collection
dotdb create-collection users

# Create a products collection
dotdb create-collection products
</code></pre>
<h3 id="delete-collection-command"><a class="header" href="#delete-collection-command">Delete Collection Command</a></h3>
<p>Delete a collection and all its documents.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb delete-collection &lt;COLLECTION&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;COLLECTION&gt;</code>: Collection name</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Delete users collection
dotdb delete-collection users

# Delete products collection
dotdb delete-collection products
</code></pre>
<p><strong>Warning:</strong> This operation is irreversible and will delete all documents in the collection.</p>
<h3 id="count-command"><a class="header" href="#count-command">Count Command</a></h3>
<p>Count the number of documents in a collection.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">dotdb count &lt;COLLECTION&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;COLLECTION&gt;</code>: Collection name</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Count users
dotdb count users
# Output: Collection 'users' contains 150 documents

# Count products
dotdb count products
# Output: Collection 'products' contains 45 documents
</code></pre>
<h2 id="json-document-format"><a class="header" href="#json-document-format">JSON Document Format</a></h2>
<p>DotDB stores documents in JSON format. Documents can contain:</p>
<ul>
<li><strong>Primitive types</strong>: strings, numbers, booleans, null</li>
<li><strong>Objects</strong>: nested JSON objects</li>
<li><strong>Arrays</strong>: lists of values</li>
<li><strong>Mixed types</strong>: combinations of the above</li>
</ul>
<h3 id="valid-json-examples"><a class="header" href="#valid-json-examples">Valid JSON Examples</a></h3>
<pre><code class="language-json">{
  "id": "user_123",
  "name": "Alice",
  "age": 30,
  "active": true,
  "address": {
    "street": "123 Main St",
    "city": "Anytown",
    "zipcode": "12345"
  },
  "hobbies": ["reading", "hiking", "coding"],
  "metadata": null
}
</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The CLI provides clear error messages for common issues:</p>
<h3 id="document-errors"><a class="header" href="#document-errors">Document Errors</a></h3>
<ul>
<li><strong>Invalid JSON</strong>: Check JSON syntax and formatting</li>
<li><strong>Document not found</strong>: Verify collection name and document ID</li>
<li><strong>Collection not found</strong>: Ensure collection exists</li>
</ul>
<h3 id="collection-errors"><a class="header" href="#collection-errors">Collection Errors</a></h3>
<ul>
<li><strong>Collection already exists</strong>: Use existing collection or choose different name</li>
<li><strong>Collection not empty</strong>: Cannot delete non-empty collection without force</li>
</ul>
<h3 id="system-errors"><a class="header" href="#system-errors">System Errors</a></h3>
<ul>
<li><strong>Permission denied</strong>: Check file system permissions</li>
<li><strong>Disk space</strong>: Ensure sufficient storage space</li>
<li><strong>Memory errors</strong>: Check available system memory</li>
</ul>
<h2 id="performance-tips-1"><a class="header" href="#performance-tips-1">Performance Tips</a></h2>
<ol>
<li><strong>Batch operations</strong>: Group multiple operations when possible</li>
<li><strong>Use appropriate field names</strong>: Short, descriptive field names improve performance</li>
<li><strong>Index frequently queried fields</strong>: Consider field access patterns</li>
<li><strong>Optimize JSON structure</strong>: Avoid deeply nested objects when possible</li>
<li><strong>Regular maintenance</strong>: Periodically clean up unused documents</li>
</ol>
<h2 id="integration-with-dotvm"><a class="header" href="#integration-with-dotvm">Integration with DotVM</a></h2>
<p>DotDB seamlessly integrates with DotVM for state management:</p>
<ul>
<li><strong>State persistence</strong>: VM state is automatically persisted</li>
<li><strong>Transaction support</strong>: Atomic operations across VM and database</li>
<li><strong>Query capabilities</strong>: Complex queries available through VM opcodes</li>
<li><strong>Performance optimization</strong>: Optimized for VM access patterns</li>
</ul>
<h2 id="workflow-examples"><a class="header" href="#workflow-examples">Workflow Examples</a></h2>
<h3 id="user-management-system"><a class="header" href="#user-management-system">User Management System</a></h3>
<ol>
<li><strong>Create users collection:</strong></li>
</ol>
<pre><code class="language-bash">dotdb create-collection users
</code></pre>
<ol start="2">
<li><strong>Add users:</strong></li>
</ol>
<pre><code class="language-bash">dotdb put users '{"name": "Alice", "email": "alice@example.com", "role": "admin"}'
dotdb put users '{"name": "Bob", "email": "bob@example.com", "role": "user"}'
dotdb put users '{"name": "Charlie", "email": "charlie@example.com", "role": "user"}'
</code></pre>
<ol start="3">
<li><strong>List all users:</strong></li>
</ol>
<pre><code class="language-bash">dotdb list users
</code></pre>
<ol start="4">
<li><strong>Find admin users:</strong></li>
</ol>
<pre><code class="language-bash">dotdb find users role '"admin"'
</code></pre>
<ol start="5">
<li><strong>Update user role:</strong></li>
</ol>
<pre><code class="language-bash">dotdb update users user_456 '{"name": "Bob", "email": "bob@example.com", "role": "admin"}'
</code></pre>
<ol start="6">
<li><strong>Count total users:</strong></li>
</ol>
<pre><code class="language-bash">dotdb count users
</code></pre>
<h3 id="product-catalog"><a class="header" href="#product-catalog">Product Catalog</a></h3>
<ol>
<li><strong>Create products collection:</strong></li>
</ol>
<pre><code class="language-bash">dotdb create-collection products
</code></pre>
<ol start="2">
<li><strong>Add products:</strong></li>
</ol>
<pre><code class="language-bash">dotdb put products '{
  "name": "Laptop Pro",
  "category": "electronics",
  "price": 1299.99,
  "stock": 50,
  "specs": {
    "cpu": "M2 Pro",
    "ram": "32GB",
    "storage": "1TB SSD"
  }
}'

dotdb put products '{
  "name": "Wireless Mouse",
  "category": "accessories", 
  "price": 29.99,
  "stock": 200
}'
</code></pre>
<ol start="3">
<li><strong>Find products by category:</strong></li>
</ol>
<pre><code class="language-bash">dotdb find products category '"electronics"'
</code></pre>
<ol start="4">
<li><strong>Update stock levels:</strong></li>
</ol>
<pre><code class="language-bash">dotdb update products prod_123 '{
  "name": "Laptop Pro",
  "category": "electronics",
  "price": 1299.99,
  "stock": 45
}'
</code></pre>
<ol start="5">
<li><strong>Check inventory:</strong></li>
</ol>
<pre><code class="language-bash">dotdb count products
</code></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="complex-queries"><a class="header" href="#complex-queries">Complex Queries</a></h3>
<p>While the CLI provides basic find functionality, complex queries can be performed through the DotVM integration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Find products with price &gt; 100 and stock &gt; 10
// This would be implemented in DotVM bytecode
<span class="boring">}</span></code></pre></pre>
<h3 id="bulk-operations"><a class="header" href="#bulk-operations">Bulk Operations</a></h3>
<p>For bulk operations, consider writing DotVM programs that use the database opcodes for better performance than individual CLI commands.</p>
<h3 id="backup-and-restore"><a class="header" href="#backup-and-restore">Backup and Restore</a></h3>
<pre><code class="language-bash"># Export all collections (conceptual - would need implementation)
dotdb export --output backup.json

# Import collections (conceptual - would need implementation)  
dotdb import --input backup.json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dotvm-overview"><a class="header" href="#dotvm-overview">DotVM Overview</a></h1>
<p>DotVM (Dotlanth Virtual Machine) is a high-performance, multi-architecture virtual machine designed for executing smart contracts and general-purpose programs with advanced parallelization capabilities.</p>
<h2 id="what-is-dotvm"><a class="header" href="#what-is-dotvm">What is DotVM?</a></h2>
<p>DotVM is a stack-based virtual machine that provides:</p>
<ul>
<li><strong>Multi-architecture support</strong>: 32, 64, 128, 256, and 512-bit architectures</li>
<li><strong>Comprehensive instruction set</strong>: Arithmetic, control flow, memory, cryptographic, SIMD, and parallel operations</li>
<li><strong>Rust-to-bytecode transpilation</strong>: Complete toolchain from Rust source code to optimized bytecode</li>
<li><strong>Advanced execution features</strong>: Debugging, profiling, and step-by-step execution</li>
<li><strong>Database integration</strong>: Seamless integration with DotDB for state management</li>
<li><strong>Security and isolation</strong>: Memory protection and secure execution environment</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="multi-architecture-support"><a class="header" href="#multi-architecture-support">Multi-Architecture Support</a></h3>
<p>DotVM supports five different architectures, each optimized for specific use cases:</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>Word Size</th><th>Best For</th></tr></thead><tbody>
<tr><td>Arch32</td><td>32-bit</td><td>IoT, embedded systems</td></tr>
<tr><td>Arch64</td><td>64-bit</td><td>General-purpose applications (default)</td></tr>
<tr><td>Arch128</td><td>128-bit</td><td>Scientific computing, high precision</td></tr>
<tr><td>Arch256</td><td>256-bit</td><td>Blockchain, cryptocurrency applications</td></tr>
<tr><td>Arch512</td><td>512-bit</td><td>Advanced cryptography, research</td></tr>
</tbody></table>
</div>
<h3 id="comprehensive-instruction-set"><a class="header" href="#comprehensive-instruction-set">Comprehensive Instruction Set</a></h3>
<p>DotVM provides a rich set of instructions organized into categories:</p>
<ul>
<li><strong>Stack Operations</strong>: <code>PUSH</code>, <code>POP</code>, <code>DUP</code>, <code>SWAP</code>, <code>ROT</code></li>
<li><strong>Arithmetic</strong>: <code>ADD</code>, <code>SUB</code>, <code>MUL</code>, <code>DIV</code>, <code>MOD</code>, <code>NEG</code></li>
<li><strong>Control Flow</strong>: <code>JMP</code>, <code>JZ</code>, <code>JNZ</code>, <code>CALL</code>, <code>RET</code>, <code>HALT</code></li>
<li><strong>Memory</strong>: <code>LOAD</code>, <code>STORE</code>, <code>ALLOC</code>, <code>FREE</code></li>
<li><strong>Cryptographic</strong>: <code>HASH</code>, <code>SIGN</code>, <code>VERIFY</code>, <code>ENCRYPT</code>, <code>DECRYPT</code></li>
<li><strong>Database</strong>: <code>DB_GET</code>, <code>DB_PUT</code>, <code>DB_DELETE</code>, <code>DB_QUERY</code></li>
<li><strong>SIMD</strong>: Vector operations for parallel processing</li>
<li><strong>BigInt</strong>: Arbitrary precision integer operations</li>
</ul>
<h3 id="transpilation-pipeline-1"><a class="header" href="#transpilation-pipeline-1">Transpilation Pipeline</a></h3>
<p>The complete Rust-to-DotVM pipeline:</p>
<pre><code>Rust Source Code
       |
   rustc (to WebAssembly)
       |
   WASM Parser
       |
   DotVM Translator
       |
   Architecture Optimizer
       |
   DotVM Bytecode
</code></pre>
<h3 id="execution-environment"><a class="header" href="#execution-environment">Execution Environment</a></h3>
<p>DotVM provides a sophisticated execution environment with:</p>
<ul>
<li><strong>Stack-based execution</strong>: Efficient stack machine with configurable stack size</li>
<li><strong>Memory management</strong>: Protected memory with allocation tracking</li>
<li><strong>Database bridge</strong>: Direct integration with DotDB for persistent state</li>
<li><strong>Debug capabilities</strong>: Instruction-level debugging and profiling</li>
<li><strong>Error handling</strong>: Comprehensive error reporting and recovery</li>
</ul>
<h2 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h2>
<h3 id="virtual-machine-components"><a class="header" href="#virtual-machine-components">Virtual Machine Components</a></h3>
<pre><code>+-------------------------------------------------------------+
|                    DotVM Runtime                            |
+-------------------------------------------------------------+
|  +-------------+  +-------------+  +-------------------+  |
|  |   Executor  |  |   Memory    |  |   Database Bridge |  |
|  |             |  |  Manager    |  |                   |  |
|  +-------------+  +-------------+  +-------------------+  |
+-------------------------------------------------------------+
|  +-------------+  +-------------+  +-------------------+  |
|  | Instruction |  |    Stack    |  |   State Manager   |  |
|  |  Decoder    |  |   Machine   |  |                   |  |
|  +-------------+  +-------------+  +-------------------+  |
+-------------------------------------------------------------+
|                    Bytecode Loader                         |
+-------------------------------------------------------------+
</code></pre>
<h3 id="bytecode-format"><a class="header" href="#bytecode-format">Bytecode Format</a></h3>
<p>DotVM bytecode files have a structured format:</p>
<pre><code>+-------------------------------------------------------------+
|                    Bytecode Header                         |
+-------------------------------------------------------------+
| Magic Number | Version | Architecture | Flags | Entry Point |
|   (4 bytes)  |(2 bytes)|   (1 byte)   |(1 byte)|  (8 bytes) |
+-------------------------------------------------------------+
|                    Code Section                            |
+-------------------------------------------------------------+
|                    Data Section                            |
+-------------------------------------------------------------+
|                   Debug Section                            |
|                   (optional)                               |
+-------------------------------------------------------------+
</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="smart-contracts"><a class="header" href="#smart-contracts">Smart Contracts</a></h3>
<ul>
<li>Blockchain applications</li>
<li>Decentralized finance (DeFi)</li>
<li>NFT platforms</li>
<li>Governance systems</li>
</ul>
<h3 id="general-computing"><a class="header" href="#general-computing">General Computing</a></h3>
<ul>
<li>Web application backends</li>
<li>Microservices</li>
<li>Data processing pipelines</li>
<li>Scientific computing</li>
</ul>
<h3 id="embedded-systems"><a class="header" href="#embedded-systems">Embedded Systems</a></h3>
<ul>
<li>IoT devices</li>
<li>Edge computing</li>
<li>Real-time systems</li>
<li>Resource-constrained environments</li>
</ul>
<h3 id="cryptographic-applications"><a class="header" href="#cryptographic-applications">Cryptographic Applications</a></h3>
<ul>
<li>Cryptocurrency wallets</li>
<li>Digital signature systems</li>
<li>Secure communication</li>
<li>Privacy-preserving protocols</li>
</ul>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="execution-speed"><a class="header" href="#execution-speed">Execution Speed</a></h3>
<ul>
<li><strong>Optimized instruction dispatch</strong>: Fast instruction decoding and execution</li>
<li><strong>Architecture-specific optimizations</strong>: Tailored performance for each architecture</li>
<li><strong>Minimal overhead</strong>: Efficient stack operations and memory management</li>
<li><strong>Parallel execution</strong>: Support for concurrent operations (ParaContracts)</li>
</ul>
<h3 id="memory-efficiency"><a class="header" href="#memory-efficiency">Memory Efficiency</a></h3>
<ul>
<li><strong>Compact bytecode</strong>: Efficient instruction encoding</li>
<li><strong>Stack-based design</strong>: Minimal register pressure</li>
<li><strong>Memory protection</strong>: Safe memory access with bounds checking</li>
<li><strong>Garbage collection</strong>: Automatic memory management (optional)</li>
</ul>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<ul>
<li><strong>Multi-threading</strong>: Parallel execution capabilities</li>
<li><strong>State management</strong>: Efficient state persistence and retrieval</li>
<li><strong>Resource isolation</strong>: Secure execution boundaries</li>
<li><strong>Load balancing</strong>: Distributed execution support</li>
</ul>
<h2 id="security-features"><a class="header" href="#security-features">Security Features</a></h2>
<h3 id="memory-safety"><a class="header" href="#memory-safety">Memory Safety</a></h3>
<ul>
<li><strong>Bounds checking</strong>: All memory accesses are validated</li>
<li><strong>Stack overflow protection</strong>: Configurable stack limits</li>
<li><strong>Type safety</strong>: Strong typing throughout execution</li>
<li><strong>Memory isolation</strong>: Programs cannot access unauthorized memory</li>
</ul>
<h3 id="execution-safety"><a class="header" href="#execution-safety">Execution Safety</a></h3>
<ul>
<li><strong>Instruction validation</strong>: All instructions are verified before execution</li>
<li><strong>Resource limits</strong>: Configurable limits on execution time and memory</li>
<li><strong>Error handling</strong>: Graceful handling of runtime errors</li>
<li><strong>Sandboxing</strong>: Isolated execution environment</li>
</ul>
<h3 id="cryptographic-security"><a class="header" href="#cryptographic-security">Cryptographic Security</a></h3>
<ul>
<li><strong>Secure random number generation</strong>: Cryptographically secure randomness</li>
<li><strong>Hash function support</strong>: Multiple hash algorithms</li>
<li><strong>Digital signatures</strong>: Built-in signature verification</li>
<li><strong>Encryption support</strong>: Symmetric and asymmetric encryption</li>
</ul>
<h2 id="integration-with-dotdb-1"><a class="header" href="#integration-with-dotdb-1">Integration with DotDB</a></h2>
<p>DotVM seamlessly integrates with DotDB for state management:</p>
<h3 id="database-operations"><a class="header" href="#database-operations">Database Operations</a></h3>
<ul>
<li><strong>Direct access</strong>: Native database opcodes for efficient operations</li>
<li><strong>Transaction support</strong>: Atomic operations across VM and database</li>
<li><strong>Query capabilities</strong>: Complex queries through VM instructions</li>
<li><strong>State persistence</strong>: Automatic state saving and restoration</li>
</ul>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<ul>
<li><strong>Caching</strong>: Intelligent caching of frequently accessed data</li>
<li><strong>Batch operations</strong>: Efficient bulk database operations</li>
<li><strong>Index utilization</strong>: Automatic use of database indices</li>
<li><strong>Connection pooling</strong>: Efficient database connection management</li>
</ul>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<h3 id="1-write-rust-code"><a class="header" href="#1-write-rust-code">1. Write Rust Code</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, DotVM!");
    let result = calculate_fibonacci(10);
    println!("Fibonacci(10) = {}", result);
}

fn calculate_fibonacci(n: u32) -&gt; u32 {
    match n {
        0 =&gt; 0,
        1 =&gt; 1,
        _ =&gt; calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2),
    }
}</code></pre></pre>
<h3 id="2-transpile-to-bytecode"><a class="header" href="#2-transpile-to-bytecode">2. Transpile to Bytecode</a></h3>
<pre><code class="language-bash">dotvm transpile -i fibonacci.rs -o fibonacci.dotvm -a arch64 --opt-level 2
</code></pre>
<h3 id="3-execute-bytecode"><a class="header" href="#3-execute-bytecode">3. Execute Bytecode</a></h3>
<pre><code class="language-bash">dotvm run fibonacci.dotvm --verbose
</code></pre>
<h3 id="4-debug-if-needed"><a class="header" href="#4-debug-if-needed">4. Debug if Needed</a></h3>
<pre><code class="language-bash">dotvm run fibonacci.dotvm --debug --step
</code></pre>
<h2 id="cli-tools"><a class="header" href="#cli-tools">CLI Tools</a></h2>
<p>DotVM provides comprehensive command-line tools:</p>
<h3 id="transpilation-tool"><a class="header" href="#transpilation-tool">Transpilation Tool</a></h3>
<ul>
<li><strong>Input formats</strong>: Rust source files or projects</li>
<li><strong>Output formats</strong>: DotVM bytecode files</li>
<li><strong>Architecture selection</strong>: Choose target VM architecture</li>
<li><strong>Optimization levels</strong>: Control compilation optimizations</li>
<li><strong>Debug information</strong>: Include debugging metadata</li>
</ul>
<h3 id="execution-tool"><a class="header" href="#execution-tool">Execution Tool</a></h3>
<ul>
<li><strong>Bytecode execution</strong>: Run DotVM bytecode files</li>
<li><strong>Debug mode</strong>: Step-by-step execution with state inspection</li>
<li><strong>Profiling</strong>: Performance analysis and timing information</li>
<li><strong>Resource monitoring</strong>: Memory and execution time tracking</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<ol>
<li><strong>Install DotVM</strong>: Follow the <a href="dotvm/../getting-started/installation.html">installation guide</a></li>
<li><strong>Try the quickstart</strong>: Complete the <a href="dotvm/../getting-started/quickstart.html">quickstart tutorial</a></li>
<li><strong>Learn the CLI</strong>: Read the <a href="dotvm/../cli/dotvm.html">CLI reference</a></li>
<li><strong>Explore examples</strong>: Check out example programs in the repository</li>
<li><strong>Read the architecture docs</strong>: Understand <a href="dotvm/architecture/vm-architectures.html">VM architectures</a></li>
</ol>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><strong>Architecture Details</strong>: Learn about <a href="dotvm/architecture/vm-architectures.html">VM architectures</a></li>
<li><strong>Instruction Set</strong>: Explore the <a href="dotvm/architecture/instruction-set.html">instruction set reference</a></li>
<li><strong>Bytecode Format</strong>: Understand the <a href="dotvm/architecture/bytecode-format.html">bytecode format</a></li>
<li><strong>Usage Guide</strong>: Read about <a href="dotvm/usage/basic-operations.html">basic operations</a></li>
<li><strong>API Reference</strong>: Check the <a href="dotvm/api/core.html">Core API documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h1>
<p>DotVM’s core architecture is designed for high-performance execution, multi-architecture support, and seamless integration with DotDB. This document provides an overview of the fundamental architectural components and design principles.</p>
<h2 id="architecture-overview-2"><a class="header" href="#architecture-overview-2">Architecture Overview</a></h2>
<p>DotVM follows a layered architecture that separates concerns and enables modularity:</p>
<pre><code>+-------------------------------------------------------------+
|                    Application Layer                       |
|  +-------------+  +-------------+  +-------------------+  |
|  |     CLI     |  |   Runtime   |  |      Tools        |  |
|  |    Tools    |  |   Services  |  |   &amp; Utilities     |  |
|  +-------------+  +-------------+  +-------------------+  |
+-------------------------------------------------------------+
|                    Execution Layer                         |
|  +-------------+  +-------------+  +-------------------+  |
|  |   Virtual   |  |   Memory    |  |    Database       |  |
|  |   Machine   |  |  Manager    |  |     Bridge        |  |
|  +-------------+  +-------------+  +-------------------+  |
+-------------------------------------------------------------+
|                    Compiler Layer                          |
|  +-------------+  +-------------+  +-------------------+  |
|  | Transpiler  |  |   Code      |  |   Optimization    |  |
|  |   Engine    |  | Generator   |  |     Engine        |  |
|  +-------------+  +-------------+  +-------------------+  |
+-------------------------------------------------------------+
|                    Foundation Layer                        |
|  +-------------+  +-------------+  +-------------------+  |
|  |   Common    |  |   Error     |  |      Types        |  |
|  | Utilities   |  |  Handling   |  |   &amp; Traits        |  |
|  +-------------+  +-------------+  +-------------------+  |
+-------------------------------------------------------------+
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="virtual-machine-engine"><a class="header" href="#virtual-machine-engine">Virtual Machine Engine</a></h3>
<p>The VM engine is the heart of DotVM, responsible for bytecode execution:</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Multi-architecture support</strong>: 32, 64, 128, 256, and 512-bit architectures</li>
<li><strong>Stack-based execution</strong>: Efficient stack machine implementation</li>
<li><strong>Instruction dispatch</strong>: Optimized instruction decoding and execution</li>
<li><strong>Memory management</strong>: Protected memory access with bounds checking</li>
<li><strong>Error handling</strong>: Comprehensive error reporting and recovery</li>
</ul>
<h3 id="instruction-set-architecture"><a class="header" href="#instruction-set-architecture">Instruction Set Architecture</a></h3>
<p>DotVM implements a comprehensive instruction set organized into categories:</p>
<p><strong>Instruction Categories:</strong></p>
<ul>
<li><strong>Stack Operations</strong>: PUSH, POP, DUP, SWAP</li>
<li><strong>Arithmetic</strong>: ADD, SUB, MUL, DIV, MOD</li>
<li><strong>Control Flow</strong>: JMP, JZ, JNZ, CALL, RET</li>
<li><strong>Memory</strong>: LOAD, STORE, ALLOC, FREE</li>
<li><strong>Database</strong>: DB_GET, DB_PUT, DB_DELETE, DB_QUERY</li>
<li><strong>Cryptographic</strong>: HASH, ENCRYPT, DECRYPT, SIGN</li>
<li><strong>SIMD</strong>: Vector operations for parallel processing</li>
<li><strong>System</strong>: I/O and system interaction</li>
</ul>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<p>DotVM provides sophisticated memory management:</p>
<p><strong>Memory Model:</strong></p>
<ul>
<li><strong>Stack Memory</strong>: Execution stack with configurable size</li>
<li><strong>Heap Memory</strong>: Dynamic allocation with garbage collection</li>
<li><strong>Static Memory</strong>: Constants and static data</li>
<li><strong>Protected Memory</strong>: Bounds checking and access control</li>
</ul>
<h2 id="execution-model"><a class="header" href="#execution-model">Execution Model</a></h2>
<h3 id="stack-based-execution"><a class="header" href="#stack-based-execution">Stack-Based Execution</a></h3>
<p>DotVM uses a stack-based execution model for simplicity and efficiency:</p>
<p><strong>Stack Operations:</strong></p>
<pre><code>Initial:    []
PUSH 10:    [10]
PUSH 5:     [10, 5]
ADD:        [15]
DUP:        [15, 15]
</code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>Simple instruction encoding</strong>: Minimal operand requirements</li>
<li><strong>Efficient execution</strong>: Fast stack operations</li>
<li><strong>Compact bytecode</strong>: Reduced memory footprint</li>
<li><strong>Easy optimization</strong>: Straightforward optimization opportunities</li>
</ul>
<h2 id="multi-architecture-support-1"><a class="header" href="#multi-architecture-support-1">Multi-Architecture Support</a></h2>
<p>DotVM supports multiple architectures, each optimized for specific use cases:</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>Word Size</th><th>Best For</th></tr></thead><tbody>
<tr><td>Arch32</td><td>32-bit</td><td>IoT, embedded systems</td></tr>
<tr><td>Arch64</td><td>64-bit</td><td>General-purpose applications</td></tr>
<tr><td>Arch128</td><td>128-bit</td><td>Scientific computing</td></tr>
<tr><td>Arch256</td><td>256-bit</td><td>Blockchain, cryptocurrency</td></tr>
<tr><td>Arch512</td><td>512-bit</td><td>Advanced cryptography</td></tr>
</tbody></table>
</div>
<h2 id="database-integration"><a class="header" href="#database-integration">Database Integration</a></h2>
<p>Seamless integration with DotDB for state management:</p>
<p><strong>Integration Features:</strong></p>
<ul>
<li><strong>Native Opcodes</strong>: Direct database operations from bytecode</li>
<li><strong>Transaction Support</strong>: Atomic operations across VM and database</li>
<li><strong>State Persistence</strong>: Automatic state saving and restoration</li>
<li><strong>Query Optimization</strong>: Efficient database query execution</li>
</ul>
<h2 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h2>
<p>DotVM is optimized for high-performance execution:</p>
<p><strong>Performance Metrics:</strong></p>
<ul>
<li><strong>Instruction Throughput</strong>: Millions of instructions per second</li>
<li><strong>Memory Efficiency</strong>: Minimal memory overhead</li>
<li><strong>Startup Time</strong>: Fast bytecode loading and initialization</li>
<li><strong>Scalability</strong>: Efficient resource utilization</li>
</ul>
<h2 id="security-features-1"><a class="header" href="#security-features-1">Security Features</a></h2>
<p>DotVM implements multiple security layers:</p>
<p><strong>Memory Security:</strong></p>
<ul>
<li><strong>Bounds Checking</strong>: Prevent buffer overflows</li>
<li><strong>Stack Protection</strong>: Guard against stack smashing</li>
<li><strong>Memory Isolation</strong>: Isolate program memory spaces</li>
<li><strong>Access Control</strong>: Fine-grained memory permissions</li>
</ul>
<p><strong>Execution Security:</strong></p>
<ul>
<li><strong>Instruction Validation</strong>: Verify instruction integrity</li>
<li><strong>Resource Limits</strong>: Prevent resource exhaustion</li>
<li><strong>Sandboxing</strong>: Isolated execution environment</li>
<li><strong>Audit Logging</strong>: Track security-relevant operations</li>
</ul>
<h2 id="development-tools"><a class="header" href="#development-tools">Development Tools</a></h2>
<p>Comprehensive tooling for development:</p>
<ul>
<li><strong>CLI Tools</strong>: Command-line interface for common operations</li>
<li><strong>Debugger</strong>: Step-by-step execution debugging</li>
<li><strong>Profiler</strong>: Performance analysis and optimization</li>
<li><strong>Disassembler</strong>: Bytecode analysis and inspection</li>
</ul>
<p>For more detailed information about specific components, see:</p>
<ul>
<li><a href="dotvm/architecture/vm-architectures.html">VM Architectures</a></li>
<li><a href="dotvm/architecture/instruction-set.html">Instruction Set</a></li>
<li><a href="dotvm/architecture/bytecode-format.html">Bytecode Format</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vm-architectures"><a class="header" href="#vm-architectures">VM Architectures</a></h1>
<p>DotVM supports multiple virtual machine architectures, each optimized for different use cases and data sizes. The architecture determines the word size, register width, and memory addressing capabilities of the virtual machine.</p>
<h2 id="supported-architectures"><a class="header" href="#supported-architectures">Supported Architectures</a></h2>
<h3 id="arch32-32-bit"><a class="header" href="#arch32-32-bit">Arch32 (32-bit)</a></h3>
<ul>
<li><strong>Word Size</strong>: 32 bits (4 bytes)</li>
<li><strong>Address Space</strong>: 4 GB (2^32 bytes)</li>
<li><strong>Register Width</strong>: 32 bits</li>
<li><strong>Use Cases</strong>: Lightweight applications, embedded systems, memory-constrained environments</li>
</ul>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Minimal memory footprint</li>
<li>Fast execution for simple operations</li>
<li>Limited address space</li>
<li>Suitable for IoT and embedded applications</li>
</ul>
<h3 id="arch64-64-bit---default"><a class="header" href="#arch64-64-bit---default">Arch64 (64-bit) - Default</a></h3>
<ul>
<li><strong>Word Size</strong>: 64 bits (8 bytes)</li>
<li><strong>Address Space</strong>: 16 EB (2^64 bytes)</li>
<li><strong>Register Width</strong>: 64 bits</li>
<li><strong>Use Cases</strong>: General-purpose applications, standard desktop/server workloads</li>
</ul>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Balanced performance and memory usage</li>
<li>Standard architecture for most applications</li>
<li>Good compatibility with modern systems</li>
<li>Default choice for most use cases</li>
</ul>
<h3 id="arch128-128-bit"><a class="header" href="#arch128-128-bit">Arch128 (128-bit)</a></h3>
<ul>
<li><strong>Word Size</strong>: 128 bits (16 bytes)</li>
<li><strong>Address Space</strong>: 2^128 bytes (theoretical)</li>
<li><strong>Register Width</strong>: 128 bits</li>
<li><strong>Use Cases</strong>: High-precision arithmetic, cryptographic applications, scientific computing</li>
</ul>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Enhanced precision for mathematical operations</li>
<li>Native support for 128-bit integers</li>
<li>Optimized for cryptographic operations</li>
<li>Suitable for financial and scientific applications</li>
</ul>
<h3 id="arch256-256-bit"><a class="header" href="#arch256-256-bit">Arch256 (256-bit)</a></h3>
<ul>
<li><strong>Word Size</strong>: 256 bits (32 bytes)</li>
<li><strong>Address Space</strong>: 2^256 bytes (theoretical)</li>
<li><strong>Register Width</strong>: 256 bits</li>
<li><strong>Use Cases</strong>: Advanced cryptography, blockchain applications, high-performance computing</li>
</ul>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Maximum precision for arithmetic operations</li>
<li>Native support for 256-bit integers</li>
<li>Optimized for blockchain and cryptocurrency operations</li>
<li>Excellent for cryptographic hash functions</li>
</ul>
<h3 id="arch512-512-bit"><a class="header" href="#arch512-512-bit">Arch512 (512-bit)</a></h3>
<ul>
<li><strong>Word Size</strong>: 512 bits (64 bytes)</li>
<li><strong>Address Space</strong>: 2^512 bytes (theoretical)</li>
<li><strong>Register Width</strong>: 512 bits</li>
<li><strong>Use Cases</strong>: Specialized cryptographic applications, research, extreme precision requirements</li>
</ul>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Highest precision available</li>
<li>Native support for 512-bit integers</li>
<li>Specialized for advanced cryptographic research</li>
<li>Maximum computational precision</li>
</ul>
<h2 id="architecture-selection-guide"><a class="header" href="#architecture-selection-guide">Architecture Selection Guide</a></h2>
<h3 id="when-to-use-each-architecture"><a class="header" href="#when-to-use-each-architecture">When to Use Each Architecture</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>Best For</th><th>Performance</th><th>Memory Usage</th><th>Precision</th></tr></thead><tbody>
<tr><td>Arch32</td><td>IoT, embedded systems</td><td>Fast</td><td>Low</td><td>Standard</td></tr>
<tr><td>Arch64</td><td>General applications</td><td>Balanced</td><td>Moderate</td><td>Good</td></tr>
<tr><td>Arch128</td><td>Scientific computing</td><td>Good</td><td>Higher</td><td>High</td></tr>
<tr><td>Arch256</td><td>Blockchain, crypto</td><td>Specialized</td><td>High</td><td>Very High</td></tr>
<tr><td>Arch512</td><td>Research, extreme precision</td><td>Specialized</td><td>Highest</td><td>Maximum</td></tr>
</tbody></table>
</div>
<h3 id="performance-characteristics-2"><a class="header" href="#performance-characteristics-2">Performance Characteristics</a></h3>
<pre><code>Execution Speed (relative):
Arch32:  ████████████████████████████████ (fastest)
Arch64:  ████████████████████████████
Arch128: ████████████████████████
Arch256: ████████████████████
Arch512: ████████████████ (specialized)

Memory Usage (relative):
Arch32:  ████████ (lowest)
Arch64:  ████████████████
Arch128: ████████████████████████
Arch256: ████████████████████████████████
Arch512: ████████████████████████████████████████ (highest)
</code></pre>
<h2 id="architecture-specific-features"><a class="header" href="#architecture-specific-features">Architecture-Specific Features</a></h2>
<h3 id="arithmetic-operations"><a class="header" href="#arithmetic-operations">Arithmetic Operations</a></h3>
<p>Each architecture provides native support for operations matching its word size:</p>
<p><strong>Arch32:</strong></p>
<ul>
<li>32-bit integer arithmetic</li>
<li>32-bit floating-point operations</li>
<li>Basic cryptographic primitives</li>
</ul>
<p><strong>Arch64:</strong></p>
<ul>
<li>64-bit integer arithmetic</li>
<li>64-bit floating-point operations</li>
<li>Standard cryptographic operations</li>
<li>Compatibility with most programming languages</li>
</ul>
<p><strong>Arch128:</strong></p>
<ul>
<li>128-bit integer arithmetic</li>
<li>Extended precision floating-point</li>
<li>Advanced cryptographic primitives</li>
<li>UUID and GUID operations</li>
</ul>
<p><strong>Arch256:</strong></p>
<ul>
<li>256-bit integer arithmetic</li>
<li>Blockchain-optimized operations</li>
<li>SHA-256 native support</li>
<li>Elliptic curve cryptography</li>
</ul>
<p><strong>Arch512:</strong></p>
<ul>
<li>512-bit integer arithmetic</li>
<li>Research-grade cryptographic operations</li>
<li>Advanced hash functions</li>
<li>Experimental mathematical operations</li>
</ul>
<h3 id="memory-model"><a class="header" href="#memory-model">Memory Model</a></h3>
<p>Each architecture has different memory alignment and addressing requirements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Memory layout examples
Arch32:  [32-bit word][32-bit word][32-bit word]...
Arch64:  [64-bit word][64-bit word][64-bit word]...
Arch128: [128-bit word][128-bit word]...
Arch256: [256-bit word][256-bit word]...
Arch512: [512-bit word]...
<span class="boring">}</span></code></pre></pre>
<h3 id="instruction-set-variations"><a class="header" href="#instruction-set-variations">Instruction Set Variations</a></h3>
<p>While all architectures share the same basic instruction set, some instructions behave differently:</p>
<p><strong>Stack Operations:</strong></p>
<ul>
<li><code>PUSH</code>: Pushes architecture-sized values</li>
<li><code>POP</code>: Pops architecture-sized values</li>
<li><code>DUP</code>: Duplicates top architecture-sized value</li>
</ul>
<p><strong>Arithmetic Operations:</strong></p>
<ul>
<li><code>ADD</code>, <code>SUB</code>, <code>MUL</code>, <code>DIV</code>: Operate on architecture-sized integers</li>
<li><code>FADD</code>, <code>FSUB</code>, <code>FMUL</code>, <code>FDIV</code>: Operate on architecture-sized floats</li>
</ul>
<p><strong>Memory Operations:</strong></p>
<ul>
<li><code>LOAD</code>, <code>STORE</code>: Transfer architecture-sized words</li>
<li><code>LOAD_BYTE</code>, <code>STORE_BYTE</code>: Always operate on single bytes</li>
</ul>
<h2 id="bytecode-compatibility"><a class="header" href="#bytecode-compatibility">Bytecode Compatibility</a></h2>
<p>Bytecode files are architecture-specific and contain the target architecture in their header:</p>
<pre><code>Bytecode Header:
[Magic: "DOTVM"][Version][Architecture][Flags][Entry Point]
</code></pre>
<p><strong>Architecture Encoding:</strong></p>
<ul>
<li>Arch32: 0x00</li>
<li>Arch64: 0x01</li>
<li>Arch128: 0x02</li>
<li>Arch256: 0x03</li>
<li>Arch512: 0x04</li>
</ul>
<h2 id="transpilation-considerations"><a class="header" href="#transpilation-considerations">Transpilation Considerations</a></h2>
<p>When transpiling Rust code to different architectures:</p>
<h3 id="data-type-mapping"><a class="header" href="#data-type-mapping">Data Type Mapping</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust Type</th><th>Arch32</th><th>Arch64</th><th>Arch128</th><th>Arch256</th><th>Arch512</th></tr></thead><tbody>
<tr><td><code>i32</code></td><td>Native</td><td>Promoted</td><td>Promoted</td><td>Promoted</td><td>Promoted</td></tr>
<tr><td><code>i64</code></td><td>Split</td><td>Native</td><td>Promoted</td><td>Promoted</td><td>Promoted</td></tr>
<tr><td><code>i128</code></td><td>Emulated</td><td>Split</td><td>Native</td><td>Promoted</td><td>Promoted</td></tr>
<tr><td><code>usize</code></td><td>32-bit</td><td>64-bit</td><td>128-bit</td><td>256-bit</td><td>512-bit</td></tr>
</tbody></table>
</div>
<h3 id="performance-implications"><a class="header" href="#performance-implications">Performance Implications</a></h3>
<p><strong>Arch32 Considerations:</strong></p>
<ul>
<li>Large integers require multiple operations</li>
<li>Limited address space may require memory management</li>
<li>Fastest for simple operations</li>
</ul>
<p><strong>Arch64 Considerations:</strong></p>
<ul>
<li>Best balance of performance and compatibility</li>
<li>Native support for most common data types</li>
<li>Recommended for general use</li>
</ul>
<p><strong>Arch128+ Considerations:</strong></p>
<ul>
<li>Larger memory footprint</li>
<li>Slower for simple operations</li>
<li>Faster for operations matching the architecture size</li>
</ul>
<h2 id="runtime-architecture-detection"><a class="header" href="#runtime-architecture-detection">Runtime Architecture Detection</a></h2>
<p>The VM runtime automatically detects and validates architecture compatibility:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pseudocode for architecture validation
fn validate_bytecode(bytecode: &amp;[u8]) -&gt; Result&lt;(), ArchError&gt; {
    let header = parse_header(bytecode)?;
    let runtime_arch = detect_runtime_architecture();
    
    if header.architecture != runtime_arch {
        return Err(ArchError::Mismatch {
            expected: runtime_arch,
            found: header.architecture,
        });
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="architecture-selection"><a class="header" href="#architecture-selection">Architecture Selection</a></h3>
<ol>
<li><strong>Start with Arch64</strong>: Use the default 64-bit architecture unless you have specific requirements</li>
<li><strong>Consider Data Types</strong>: Choose architecture based on your primary data types</li>
<li><strong>Evaluate Performance</strong>: Profile your application with different architectures</li>
<li><strong>Memory Constraints</strong>: Use smaller architectures for memory-limited environments</li>
</ol>
<h3 id="optimization-tips"><a class="header" href="#optimization-tips">Optimization Tips</a></h3>
<ol>
<li><strong>Match Operations to Architecture</strong>: Use operations that align with your chosen architecture</li>
<li><strong>Avoid Unnecessary Precision</strong>: Don’t use larger architectures unless needed</li>
<li><strong>Consider Cache Effects</strong>: Larger word sizes may impact cache performance</li>
<li><strong>Profile Real Workloads</strong>: Test with realistic data and operations</li>
</ol>
<h3 id="cross-architecture-development"><a class="header" href="#cross-architecture-development">Cross-Architecture Development</a></h3>
<ol>
<li><strong>Abstract Data Types</strong>: Use appropriate abstractions in your Rust code</li>
<li><strong>Test Multiple Architectures</strong>: Validate behavior across different architectures</li>
<li><strong>Document Requirements</strong>: Clearly specify architecture requirements</li>
<li><strong>Consider Portability</strong>: Design for multiple architectures when possible</li>
</ol>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="selecting-architecture-for-different-use-cases"><a class="header" href="#selecting-architecture-for-different-use-cases">Selecting Architecture for Different Use Cases</a></h3>
<p><strong>IoT Sensor Application (Arch32):</strong></p>
<pre><code class="language-bash">dotvm transpile -i sensor.rs -o sensor.dotvm -a arch32
</code></pre>
<p><strong>Web Application Backend (Arch64):</strong></p>
<pre><code class="language-bash">dotvm transpile -i webapp.rs -o webapp.dotvm -a arch64
</code></pre>
<p><strong>Cryptocurrency Wallet (Arch256):</strong></p>
<pre><code class="language-bash">dotvm transpile -i wallet.rs -o wallet.dotvm -a arch256
</code></pre>
<p><strong>Scientific Computing (Arch128):</strong></p>
<pre><code class="language-bash">dotvm transpile -i simulation.rs -o simulation.dotvm -a arch128
</code></pre>
<h3 id="performance-comparison"><a class="header" href="#performance-comparison">Performance Comparison</a></h3>
<pre><code class="language-bash"># Create test program
echo 'fn main() { 
    let mut sum = 0u64; 
    for i in 0..1000000 { 
        sum += i; 
    } 
    println!("Sum: {}", sum); 
}' &gt; perf_test.rs

# Test different architectures
dotvm transpile -i perf_test.rs -o test_32.dotvm -a arch32
dotvm transpile -i perf_test.rs -o test_64.dotvm -a arch64
dotvm transpile -i perf_test.rs -o test_128.dotvm -a arch128

# Compare execution times
time dotvm run test_32.dotvm
time dotvm run test_64.dotvm  
time dotvm run test_128.dotvm
</code></pre>
<h2 id="future-considerations"><a class="header" href="#future-considerations">Future Considerations</a></h2>
<p>The architecture system is designed to be extensible:</p>
<ul>
<li><strong>New Architectures</strong>: Additional architectures can be added as needed</li>
<li><strong>Specialized Instructions</strong>: Architecture-specific instruction sets</li>
<li><strong>Hardware Acceleration</strong>: Native hardware support for specific architectures</li>
<li><strong>Dynamic Architecture</strong>: Runtime architecture switching (future feature)</li>
</ul>
<p>For more information about specific instruction sets, see the <a href="dotvm/architecture/instruction-set.html">Instruction Set</a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instruction-set-reference"><a class="header" href="#instruction-set-reference">Instruction Set Reference</a></h1>
<p>DotVM provides a comprehensive instruction set organized into categories. Each instruction operates on the virtual machine’s stack and can access memory, perform computations, and interact with the database.</p>
<h2 id="instruction-categories"><a class="header" href="#instruction-categories">Instruction Categories</a></h2>
<p>The DotVM instruction set is organized into the following categories:</p>
<ul>
<li><a href="dotvm/architecture/instruction-set.html#stack-operations">Stack Operations</a> - Stack manipulation</li>
<li><a href="dotvm/architecture/instruction-set.html#arithmetic-operations">Arithmetic Operations</a> - Mathematical computations</li>
<li><a href="dotvm/architecture/instruction-set.html#control-flow">Control Flow</a> - Program flow control</li>
<li><a href="dotvm/architecture/instruction-set.html#memory-operations">Memory Operations</a> - Memory access and management</li>
<li><a href="dotvm/architecture/instruction-set.html#cryptographic-operations">Cryptographic Operations</a> - Cryptographic functions</li>
<li><a href="dotvm/architecture/instruction-set.html#database-operations">Database Operations</a> - Database interaction</li>
</ul>
<h2 id="stack-operations"><a class="header" href="#stack-operations">Stack Operations</a></h2>
<p>Stack operations manipulate the execution stack, which is the primary data structure for DotVM execution.</p>
<h3 id="push-0x10"><a class="header" href="#push-0x10">PUSH (0x10)</a></h3>
<p>Push a constant value onto the stack.</p>
<p><strong>Format:</strong> <code>PUSH &lt;constant_id&gt;</code>
<strong>Stack Effect:</strong> <code>[] -&gt; [value]</code>
<strong>Description:</strong> Pushes the constant identified by <code>constant_id</code> onto the stack.</p>
<p><strong>Example:</strong></p>
<pre><code>PUSH 42    ; Push integer 42 onto stack
PUSH 3.14  ; Push float 3.14 onto stack
</code></pre>
<h3 id="pop-0x11"><a class="header" href="#pop-0x11">POP (0x11)</a></h3>
<p>Remove the top value from the stack.</p>
<p><strong>Format:</strong> <code>POP</code>
<strong>Stack Effect:</strong> <code>[value] -&gt; []</code>
<strong>Description:</strong> Removes and discards the top value from the stack.</p>
<h3 id="dup-0x12"><a class="header" href="#dup-0x12">DUP (0x12)</a></h3>
<p>Duplicate the top value on the stack.</p>
<p><strong>Format:</strong> <code>DUP</code>
<strong>Stack Effect:</strong> <code>[value] -&gt; [value, value]</code>
<strong>Description:</strong> Duplicates the top stack value.</p>
<h3 id="swap-0x13"><a class="header" href="#swap-0x13">SWAP (0x13)</a></h3>
<p>Swap the top two values on the stack.</p>
<p><strong>Format:</strong> <code>SWAP</code>
<strong>Stack Effect:</strong> <code>[a, b] -&gt; [b, a]</code>
<strong>Description:</strong> Exchanges the positions of the top two stack values.</p>
<h3 id="push_null-0x14"><a class="header" href="#push_null-0x14">PUSH_NULL (0x14)</a></h3>
<p>Push a null value onto the stack.</p>
<p><strong>Format:</strong> <code>PUSH_NULL</code>
<strong>Stack Effect:</strong> <code>[] -&gt; [null]</code></p>
<h3 id="push_true-0x15"><a class="header" href="#push_true-0x15">PUSH_TRUE (0x15)</a></h3>
<p>Push boolean true onto the stack.</p>
<p><strong>Format:</strong> <code>PUSH_TRUE</code>
<strong>Stack Effect:</strong> <code>[] -&gt; [true]</code></p>
<h3 id="push_false-0x16"><a class="header" href="#push_false-0x16">PUSH_FALSE (0x16)</a></h3>
<p>Push boolean false onto the stack.</p>
<p><strong>Format:</strong> <code>PUSH_FALSE</code>
<strong>Stack Effect:</strong> <code>[] -&gt; [false]</code></p>
<h2 id="arithmetic-operations-1"><a class="header" href="#arithmetic-operations-1">Arithmetic Operations</a></h2>
<p>Arithmetic operations perform mathematical computations on stack values.</p>
<h3 id="add-0x01"><a class="header" href="#add-0x01">ADD (0x01)</a></h3>
<p>Add two values.</p>
<p><strong>Format:</strong> <code>ADD</code>
<strong>Stack Effect:</strong> <code>[a, b] -&gt; [a + b]</code>
<strong>Description:</strong> Pops two values, adds them, and pushes the result.</p>
<p><strong>Example:</strong></p>
<pre><code>PUSH 10
PUSH 5
ADD        ; Stack: [15]
</code></pre>
<h3 id="sub-0x02"><a class="header" href="#sub-0x02">SUB (0x02)</a></h3>
<p>Subtract two values.</p>
<p><strong>Format:</strong> <code>SUB</code>
<strong>Stack Effect:</strong> <code>[a, b] -&gt; [a - b]</code>
<strong>Description:</strong> Pops two values, subtracts the top from the second, and pushes the result.</p>
<h3 id="mul-0x03"><a class="header" href="#mul-0x03">MUL (0x03)</a></h3>
<p>Multiply two values.</p>
<p><strong>Format:</strong> <code>MUL</code>
<strong>Stack Effect:</strong> <code>[a, b] -&gt; [a * b]</code></p>
<h3 id="div-0x04"><a class="header" href="#div-0x04">DIV (0x04)</a></h3>
<p>Divide two values.</p>
<p><strong>Format:</strong> <code>DIV</code>
<strong>Stack Effect:</strong> <code>[a, b] -&gt; [a / b]</code>
<strong>Description:</strong> Performs division. Throws error on division by zero.</p>
<h3 id="mod-0x05"><a class="header" href="#mod-0x05">MOD (0x05)</a></h3>
<p>Modulus operation.</p>
<p><strong>Format:</strong> <code>MOD</code>
<strong>Stack Effect:</strong> <code>[a, b] -&gt; [a % b]</code>
<strong>Description:</strong> Returns the remainder of division.</p>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>Control flow instructions manage program execution flow.</p>
<h3 id="ifelse-0x10"><a class="header" href="#ifelse-0x10">IFELSE (0x10)</a></h3>
<p>Conditional execution.</p>
<p><strong>Format:</strong> <code>IFELSE &lt;then_addr&gt; &lt;else_addr&gt;</code>
<strong>Stack Effect:</strong> <code>[condition] -&gt; []</code>
<strong>Description:</strong> Pops a condition. If true, jumps to <code>then_addr</code>, otherwise to <code>else_addr</code>.</p>
<h3 id="forloop-0x11"><a class="header" href="#forloop-0x11">FORLOOP (0x11)</a></h3>
<p>For loop construct.</p>
<p><strong>Format:</strong> <code>FORLOOP &lt;start&gt; &lt;end&gt; &lt;body_addr&gt;</code>
<strong>Description:</strong> Executes a counted loop from start to end.</p>
<h3 id="whileloop-0x12"><a class="header" href="#whileloop-0x12">WHILELOOP (0x12)</a></h3>
<p>While loop construct.</p>
<p><strong>Format:</strong> <code>WHILELOOP &lt;condition_addr&gt; &lt;body_addr&gt;</code>
<strong>Description:</strong> Executes loop while condition is true.</p>
<h3 id="dowhileloop-0x13"><a class="header" href="#dowhileloop-0x13">DOWHILELOOP (0x13)</a></h3>
<p>Do-while loop construct.</p>
<p><strong>Format:</strong> <code>DOWHILELOOP &lt;body_addr&gt; &lt;condition_addr&gt;</code>
<strong>Description:</strong> Executes loop body at least once, then while condition is true.</p>
<h3 id="jump-0x14"><a class="header" href="#jump-0x14">JUMP (0x14)</a></h3>
<p>Unconditional jump.</p>
<p><strong>Format:</strong> <code>JUMP &lt;address&gt;</code>
<strong>Description:</strong> Jumps to the specified address.</p>
<h2 id="memory-operations"><a class="header" href="#memory-operations">Memory Operations</a></h2>
<p>Memory operations provide access to the virtual machine’s memory space.</p>
<h3 id="load-0x20"><a class="header" href="#load-0x20">LOAD (0x20)</a></h3>
<p>Load value from memory.</p>
<p><strong>Format:</strong> <code>LOAD &lt;address&gt;</code>
<strong>Stack Effect:</strong> <code>[] -&gt; [value]</code>
<strong>Description:</strong> Loads a value from the specified memory address and pushes it onto the stack.</p>
<h3 id="store-0x21"><a class="header" href="#store-0x21">STORE (0x21)</a></h3>
<p>Store value to memory.</p>
<p><strong>Format:</strong> <code>STORE &lt;address&gt;</code>
<strong>Stack Effect:</strong> <code>[value] -&gt; []</code>
<strong>Description:</strong> Pops a value from the stack and stores it at the specified memory address.</p>
<h3 id="allocate-0x22"><a class="header" href="#allocate-0x22">ALLOCATE (0x22)</a></h3>
<p>Allocate memory.</p>
<p><strong>Format:</strong> <code>ALLOCATE &lt;size&gt;</code>
<strong>Stack Effect:</strong> <code>[] -&gt; [address]</code>
<strong>Description:</strong> Allocates a block of memory and pushes the address onto the stack.</p>
<h3 id="deallocate-0x23"><a class="header" href="#deallocate-0x23">DEALLOCATE (0x23)</a></h3>
<p>Deallocate memory.</p>
<p><strong>Format:</strong> <code>DEALLOCATE</code>
<strong>Stack Effect:</strong> <code>[address] -&gt; []</code>
<strong>Description:</strong> Deallocates the memory block at the specified address.</p>
<h3 id="pointeroperation-0x24"><a class="header" href="#pointeroperation-0x24">POINTEROPERATION (0x24)</a></h3>
<p>Pointer arithmetic and operations.</p>
<p><strong>Format:</strong> <code>POINTEROPERATION &lt;operation&gt;</code>
<strong>Description:</strong> Performs various pointer operations like dereferencing, arithmetic, etc.</p>
<h2 id="cryptographic-operations"><a class="header" href="#cryptographic-operations">Cryptographic Operations</a></h2>
<p>Cryptographic operations provide security and hashing functions.</p>
<h3 id="crypto_hash-0x40"><a class="header" href="#crypto_hash-0x40">CRYPTO_HASH (0x40)</a></h3>
<p>Compute cryptographic hash.</p>
<p><strong>Format:</strong> <code>CRYPTO_HASH &lt;algorithm&gt;</code>
<strong>Stack Effect:</strong> <code>[data] -&gt; [hash]</code>
<strong>Description:</strong> Computes hash of the data using the specified algorithm (SHA-256, Blake3, etc.).</p>
<p><strong>Example:</strong></p>
<pre><code>PUSH "hello world"
CRYPTO_HASH SHA256    ; Stack: [hash_value]
</code></pre>
<h3 id="crypto_encrypt-0x41"><a class="header" href="#crypto_encrypt-0x41">CRYPTO_ENCRYPT (0x41)</a></h3>
<p>Encrypt data.</p>
<p><strong>Format:</strong> <code>CRYPTO_ENCRYPT &lt;algorithm&gt;</code>
<strong>Stack Effect:</strong> <code>[data, key] -&gt; [encrypted_data]</code>
<strong>Description:</strong> Encrypts data using the specified algorithm and key.</p>
<h3 id="crypto_decrypt-0x42"><a class="header" href="#crypto_decrypt-0x42">CRYPTO_DECRYPT (0x42)</a></h3>
<p>Decrypt data.</p>
<p><strong>Format:</strong> <code>CRYPTO_DECRYPT &lt;algorithm&gt;</code>
<strong>Stack Effect:</strong> <code>[encrypted_data, key] -&gt; [data]</code>
<strong>Description:</strong> Decrypts data using the specified algorithm and key.</p>
<h3 id="crypto_sign-0x43"><a class="header" href="#crypto_sign-0x43">CRYPTO_SIGN (0x43)</a></h3>
<p>Create digital signature.</p>
<p><strong>Format:</strong> <code>CRYPTO_SIGN &lt;algorithm&gt;</code>
<strong>Stack Effect:</strong> <code>[data, private_key] -&gt; [signature]</code>
<strong>Description:</strong> Creates a digital signature for the data.</p>
<h3 id="crypto_verify_signature-0x44"><a class="header" href="#crypto_verify_signature-0x44">CRYPTO_VERIFY_SIGNATURE (0x44)</a></h3>
<p>Verify digital signature.</p>
<p><strong>Format:</strong> <code>CRYPTO_VERIFY_SIGNATURE &lt;algorithm&gt;</code>
<strong>Stack Effect:</strong> <code>[data, signature, public_key] -&gt; [valid]</code>
<strong>Description:</strong> Verifies a digital signature, pushes boolean result.</p>
<h2 id="database-operations-1"><a class="header" href="#database-operations-1">Database Operations</a></h2>
<p>Database operations provide integration with DotDB for persistent state management.</p>
<h3 id="db_get-0x50"><a class="header" href="#db_get-0x50">DB_GET (0x50)</a></h3>
<p>Retrieve value from database.</p>
<p><strong>Format:</strong> <code>DB_GET</code>
<strong>Stack Effect:</strong> <code>[collection, key] -&gt; [value]</code>
<strong>Description:</strong> Retrieves a value from the specified collection and key.</p>
<p><strong>Example:</strong></p>
<pre><code>PUSH "users"
PUSH "user_123"
DB_GET             ; Stack: [user_data]
</code></pre>
<h3 id="db_put-0x51"><a class="header" href="#db_put-0x51">DB_PUT (0x51)</a></h3>
<p>Store value in database.</p>
<p><strong>Format:</strong> <code>DB_PUT</code>
<strong>Stack Effect:</strong> <code>[collection, key, value] -&gt; []</code>
<strong>Description:</strong> Stores a value in the database with the specified collection and key.</p>
<p><strong>Example:</strong></p>
<pre><code>PUSH "users"
PUSH "user_123"
PUSH {"name": "Alice", "age": 30}
DB_PUT             ; Stores user data
</code></pre>
<h3 id="db_delete-0x52"><a class="header" href="#db_delete-0x52">DB_DELETE (0x52)</a></h3>
<p>Delete value from database.</p>
<p><strong>Format:</strong> <code>DB_DELETE</code>
<strong>Stack Effect:</strong> <code>[collection, key] -&gt; []</code>
<strong>Description:</strong> Deletes the value associated with the collection and key.</p>
<h3 id="db_query-0x53"><a class="header" href="#db_query-0x53">DB_QUERY (0x53)</a></h3>
<p>Query database.</p>
<p><strong>Format:</strong> <code>DB_QUERY</code>
<strong>Stack Effect:</strong> <code>[collection, query] -&gt; [results]</code>
<strong>Description:</strong> Executes a query against the database and returns results.</p>
<h3 id="db_count-0x54"><a class="header" href="#db_count-0x54">DB_COUNT (0x54)</a></h3>
<p>Count documents in collection.</p>
<p><strong>Format:</strong> <code>DB_COUNT</code>
<strong>Stack Effect:</strong> <code>[collection] -&gt; [count]</code>
<strong>Description:</strong> Returns the number of documents in the specified collection.</p>
<h2 id="instruction-encoding"><a class="header" href="#instruction-encoding">Instruction Encoding</a></h2>
<p>Instructions are encoded in bytecode format with the following structure:</p>
<pre><code>+--------+--------+--------+--------+
| Opcode | Operand 1 (optional)     |
+--------+--------+--------+--------+
| Operand 2 (optional)             |
+--------+--------+--------+--------+
</code></pre>
<h3 id="opcode-ranges"><a class="header" href="#opcode-ranges">Opcode Ranges</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Range</th><th>Category</th></tr></thead><tbody>
<tr><td>0x01-0x0F</td><td>Arithmetic</td></tr>
<tr><td>0x10-0x1F</td><td>Stack Operations</td></tr>
<tr><td>0x20-0x2F</td><td>Memory Operations</td></tr>
<tr><td>0x30-0x3F</td><td>Control Flow</td></tr>
<tr><td>0x40-0x4F</td><td>Cryptographic</td></tr>
<tr><td>0x50-0x5F</td><td>Database</td></tr>
<tr><td>0x60-0x6F</td><td>SIMD</td></tr>
<tr><td>0x70-0x7F</td><td>BigInt</td></tr>
<tr><td>0x80-0x8F</td><td>Vector</td></tr>
<tr><td>0x90-0x9F</td><td>Parallel</td></tr>
<tr><td>0xA0-0xAF</td><td>System Calls</td></tr>
<tr><td>0xB0-0xBF</td><td>Architecture-Specific</td></tr>
</tbody></table>
</div>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="simple-arithmetic"><a class="header" href="#simple-arithmetic">Simple Arithmetic</a></h3>
<pre><code class="language-assembly">PUSH 10        ; Stack: [10]
PUSH 5         ; Stack: [10, 5]
ADD            ; Stack: [15]
PUSH 2         ; Stack: [15, 2]
MUL            ; Stack: [30]
</code></pre>
<h3 id="conditional-execution"><a class="header" href="#conditional-execution">Conditional Execution</a></h3>
<pre><code class="language-assembly">PUSH 1
PUSH 2
SUB            ; Stack: [-1]
IFELSE label_negative label_positive

label_negative:
    PUSH "Negative"
    SYSCALL_PRINT
    JUMP end

label_positive:
    PUSH "Positive"
    SYSCALL_PRINT

end:
    HALT
</code></pre>
<h3 id="database-operations-2"><a class="header" href="#database-operations-2">Database Operations</a></h3>
<pre><code class="language-assembly">; Store user data
PUSH "users"
PUSH "alice"
PUSH {"name": "Alice", "age": 30}
DB_PUT

; Retrieve user data
PUSH "users"
PUSH "alice"
DB_GET         ; Stack: [user_data]
</code></pre>
<p>For more detailed information about specific instruction categories, see the related documentation sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytecode-format-1"><a class="header" href="#bytecode-format-1">Bytecode Format</a></h1>
<p>DotVM bytecode files use a structured binary format that contains the compiled program along with metadata, constants, and optional debug information.</p>
<h2 id="file-structure-overview"><a class="header" href="#file-structure-overview">File Structure Overview</a></h2>
<pre><code>+-------------------------------------------------------------+
|                    File Header                              |
+-------------------------------------------------------------+
|                    Code Section                            |
+-------------------------------------------------------------+
|                    Data Section                            |
+-------------------------------------------------------------+
|                   Debug Section                            |
|                   (optional)                               |
+-------------------------------------------------------------+
</code></pre>
<h2 id="file-header"><a class="header" href="#file-header">File Header</a></h2>
<p>The file header contains essential metadata about the bytecode file:</p>
<pre><code>+--------+--------+--------+--------+--------+--------+--------+--------+
| Magic Number (4 bytes)           | Version (2 bytes) | Arch | Flags  |
+--------+--------+--------+--------+--------+--------+--------+--------+
| Entry Point (8 bytes)                                                |
+--------+--------+--------+--------+--------+--------+--------+--------+
| Code Section Offset (8 bytes)                                        |
+--------+--------+--------+--------+--------+--------+--------+--------+
| Code Section Size (8 bytes)                                          |
+--------+--------+--------+--------+--------+--------+--------+--------+
| Data Section Offset (8 bytes)                                        |
+--------+--------+--------+--------+--------+--------+--------+--------+
| Data Section Size (8 bytes)                                          |
+--------+--------+--------+--------+--------+--------+--------+--------+
| Debug Section Offset (8 bytes)                                       |
+--------+--------+--------+--------+--------+--------+--------+--------+
| Debug Section Size (8 bytes)                                         |
+--------+--------+--------+--------+--------+--------+--------+--------+
</code></pre>
<h3 id="header-fields"><a class="header" href="#header-fields">Header Fields</a></h3>
<h4 id="magic-number-4-bytes"><a class="header" href="#magic-number-4-bytes">Magic Number (4 bytes)</a></h4>
<ul>
<li><strong>Value</strong>: <code>0x444F5456</code> (“DOTV” in ASCII)</li>
<li><strong>Purpose</strong>: File format identification</li>
<li><strong>Validation</strong>: Must match exactly for valid bytecode</li>
</ul>
<h4 id="version-2-bytes"><a class="header" href="#version-2-bytes">Version (2 bytes)</a></h4>
<ul>
<li><strong>Format</strong>: Major.Minor (1 byte each)</li>
<li><strong>Current</strong>: 0x0001 (version 0.1)</li>
<li><strong>Purpose</strong>: Bytecode format version compatibility</li>
</ul>
<h4 id="architecture-1-byte"><a class="header" href="#architecture-1-byte">Architecture (1 byte)</a></h4>
<ul>
<li><strong>Arch32</strong>: 0x00</li>
<li><strong>Arch64</strong>: 0x01 (default)</li>
<li><strong>Arch128</strong>: 0x02</li>
<li><strong>Arch256</strong>: 0x03</li>
<li><strong>Arch512</strong>: 0x04</li>
</ul>
<h4 id="flags-1-byte"><a class="header" href="#flags-1-byte">Flags (1 byte)</a></h4>
<p>Bitfield containing various flags:</p>
<div class="table-wrapper"><table><thead><tr><th>Bit</th><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>DEBUG</td><td>Debug information present</td></tr>
<tr><td>1</td><td>COMPRESSED</td><td>Code section is compressed</td></tr>
<tr><td>2</td><td>ENCRYPTED</td><td>Bytecode is encrypted</td></tr>
<tr><td>3</td><td>SIGNED</td><td>Digital signature present</td></tr>
<tr><td>4-7</td><td>RESERVED</td><td>Reserved for future use</td></tr>
</tbody></table>
</div>
<h4 id="entry-point-8-bytes"><a class="header" href="#entry-point-8-bytes">Entry Point (8 bytes)</a></h4>
<ul>
<li><strong>Purpose</strong>: Starting address for program execution</li>
<li><strong>Format</strong>: 64-bit unsigned integer</li>
<li><strong>Default</strong>: 0x0000000000000000 (start of code section)</li>
</ul>
<h4 id="section-offsets-and-sizes-8-bytes-each"><a class="header" href="#section-offsets-and-sizes-8-bytes-each">Section Offsets and Sizes (8 bytes each)</a></h4>
<ul>
<li><strong>Offset</strong>: Byte offset from start of file</li>
<li><strong>Size</strong>: Size of section in bytes</li>
<li><strong>Purpose</strong>: Allows random access to sections</li>
</ul>
<h2 id="code-section"><a class="header" href="#code-section">Code Section</a></h2>
<p>The code section contains the actual bytecode instructions:</p>
<pre><code>+--------+--------+--------+--------+
| Instruction Count (4 bytes)      |
+--------+--------+--------+--------+
| Instruction 1                     |
+--------+--------+--------+--------+
| Instruction 2                     |
+--------+--------+--------+--------+
| ...                               |
+--------+--------+--------+--------+
| Instruction N                     |
+--------+--------+--------+--------+
</code></pre>
<h3 id="instruction-format"><a class="header" href="#instruction-format">Instruction Format</a></h3>
<p>Each instruction has a variable-length encoding:</p>
<pre><code>+--------+--------+--------+--------+
| Opcode | Operand Count | Operands... |
+--------+--------+--------+--------+
</code></pre>
<h4 id="opcode-1-byte"><a class="header" href="#opcode-1-byte">Opcode (1 byte)</a></h4>
<ul>
<li><strong>Range</strong>: 0x01-0xFF</li>
<li><strong>Purpose</strong>: Identifies the instruction type</li>
<li><strong>Categories</strong>: See <a href="dotvm/architecture/instruction-set.html">Instruction Set</a> for details</li>
</ul>
<h4 id="operand-count-1-byte"><a class="header" href="#operand-count-1-byte">Operand Count (1 byte)</a></h4>
<ul>
<li><strong>Range</strong>: 0-255</li>
<li><strong>Purpose</strong>: Number of operands following the opcode</li>
<li><strong>Note</strong>: Most instructions have 0-2 operands</li>
</ul>
<h4 id="operands-variable-length"><a class="header" href="#operands-variable-length">Operands (variable length)</a></h4>
<ul>
<li><strong>Format</strong>: Depends on instruction type</li>
<li><strong>Types</strong>: Immediate values, addresses, constant references</li>
</ul>
<h3 id="operand-types"><a class="header" href="#operand-types">Operand Types</a></h3>
<h4 id="immediate-values"><a class="header" href="#immediate-values">Immediate Values</a></h4>
<ul>
<li><strong>8-bit</strong>: 1 byte</li>
<li><strong>16-bit</strong>: 2 bytes (little-endian)</li>
<li><strong>32-bit</strong>: 4 bytes (little-endian)</li>
<li><strong>64-bit</strong>: 8 bytes (little-endian)</li>
</ul>
<h4 id="addresses"><a class="header" href="#addresses">Addresses</a></h4>
<ul>
<li><strong>Format</strong>: Architecture-dependent</li>
<li><strong>Arch32</strong>: 4 bytes</li>
<li><strong>Arch64</strong>: 8 bytes</li>
<li><strong>Arch128+</strong>: 8 bytes (logical addressing)</li>
</ul>
<h4 id="constant-references"><a class="header" href="#constant-references">Constant References</a></h4>
<ul>
<li><strong>Format</strong>: 4-byte index into data section</li>
<li><strong>Purpose</strong>: Reference to constants in data section</li>
</ul>
<h2 id="data-section"><a class="header" href="#data-section">Data Section</a></h2>
<p>The data section contains constants and static data:</p>
<pre><code>+--------+--------+--------+--------+
| Constant Count (4 bytes)         |
+--------+--------+--------+--------+
| Constant Table                    |
+--------+--------+--------+--------+
| String Pool                       |
+--------+--------+--------+--------+
| Binary Data                       |
+--------+--------+--------+--------+
</code></pre>
<h3 id="constant-table"><a class="header" href="#constant-table">Constant Table</a></h3>
<p>The constant table provides metadata for each constant:</p>
<pre><code>+--------+--------+--------+--------+
| Type   | Size (4 bytes)           |
+--------+--------+--------+--------+
| Offset (4 bytes)                  |
+--------+--------+--------+--------+
</code></pre>
<h4 id="constant-types"><a class="header" href="#constant-types">Constant Types</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>NULL</td><td>0x00</td><td>Null value</td></tr>
<tr><td>BOOL</td><td>0x01</td><td>Boolean value</td></tr>
<tr><td>INT8</td><td>0x02</td><td>8-bit signed integer</td></tr>
<tr><td>INT16</td><td>0x03</td><td>16-bit signed integer</td></tr>
<tr><td>INT32</td><td>0x04</td><td>32-bit signed integer</td></tr>
<tr><td>INT64</td><td>0x05</td><td>64-bit signed integer</td></tr>
<tr><td>UINT8</td><td>0x06</td><td>8-bit unsigned integer</td></tr>
<tr><td>UINT16</td><td>0x07</td><td>16-bit unsigned integer</td></tr>
<tr><td>UINT32</td><td>0x08</td><td>32-bit unsigned integer</td></tr>
<tr><td>UINT64</td><td>0x09</td><td>64-bit unsigned integer</td></tr>
<tr><td>FLOAT32</td><td>0x0A</td><td>32-bit IEEE 754 float</td></tr>
<tr><td>FLOAT64</td><td>0x0B</td><td>64-bit IEEE 754 float</td></tr>
<tr><td>STRING</td><td>0x0C</td><td>UTF-8 string</td></tr>
<tr><td>BYTES</td><td>0x0D</td><td>Binary data</td></tr>
<tr><td>BIGINT</td><td>0x0E</td><td>Arbitrary precision integer</td></tr>
</tbody></table>
</div>
<h3 id="string-pool"><a class="header" href="#string-pool">String Pool</a></h3>
<p>Strings are stored in a dedicated pool with length prefixes:</p>
<pre><code>+--------+--------+--------+--------+
| Length (4 bytes)                  |
+--------+--------+--------+--------+
| UTF-8 String Data...              |
+--------+--------+--------+--------+
</code></pre>
<h3 id="binary-data"><a class="header" href="#binary-data">Binary Data</a></h3>
<p>Binary constants are stored with length prefixes:</p>
<pre><code>+--------+--------+--------+--------+
| Length (4 bytes)                  |
+--------+--------+--------+--------+
| Binary Data...                    |
+--------+--------+--------+--------+
</code></pre>
<h2 id="debug-section-optional"><a class="header" href="#debug-section-optional">Debug Section (Optional)</a></h2>
<p>The debug section contains information for debugging and profiling:</p>
<pre><code>+--------+--------+--------+--------+
| Debug Info Version (2 bytes)     |
+--------+--------+--------+--------+
| Source Map Table                  |
+--------+--------+--------+--------+
| Symbol Table                      |
+--------+--------+--------+--------+
| Line Number Table                 |
+--------+--------+--------+--------+
</code></pre>
<h3 id="source-map-table"><a class="header" href="#source-map-table">Source Map Table</a></h3>
<p>Maps bytecode addresses to source code locations:</p>
<pre><code>+--------+--------+--------+--------+
| Entry Count (4 bytes)            |
+--------+--------+--------+--------+
| Bytecode Address (8 bytes)        |
+--------+--------+--------+--------+
| Source File ID (4 bytes)         |
+--------+--------+--------+--------+
| Line Number (4 bytes)            |
+--------+--------+--------+--------+
| Column Number (4 bytes)          |
+--------+--------+--------+--------+
</code></pre>
<h3 id="symbol-table"><a class="header" href="#symbol-table">Symbol Table</a></h3>
<p>Contains function and variable names:</p>
<pre><code>+--------+--------+--------+--------+
| Symbol Count (4 bytes)           |
+--------+--------+--------+--------+
| Symbol Type | Name Length        |
+--------+--------+--------+--------+
| Name (UTF-8)...                   |
+--------+--------+--------+--------+
| Address (8 bytes)                 |
+--------+--------+--------+--------+
</code></pre>
<h2 id="file-format-validation"><a class="header" href="#file-format-validation">File Format Validation</a></h2>
<h3 id="header-validation"><a class="header" href="#header-validation">Header Validation</a></h3>
<ol>
<li><strong>Magic Number</strong>: Must be <code>0x444F5456</code></li>
<li><strong>Version</strong>: Must be supported by runtime</li>
<li><strong>Architecture</strong>: Must match runtime architecture</li>
<li><strong>Section Offsets</strong>: Must be within file bounds</li>
<li><strong>Section Sizes</strong>: Must not exceed file size</li>
</ol>
<h3 id="code-section-validation"><a class="header" href="#code-section-validation">Code Section Validation</a></h3>
<ol>
<li><strong>Instruction Count</strong>: Must match actual instructions</li>
<li><strong>Opcodes</strong>: Must be valid instruction opcodes</li>
<li><strong>Operands</strong>: Must match instruction requirements</li>
<li><strong>Addresses</strong>: Must be within valid ranges</li>
</ol>
<h3 id="data-section-validation"><a class="header" href="#data-section-validation">Data Section Validation</a></h3>
<ol>
<li><strong>Constant Count</strong>: Must match constant table entries</li>
<li><strong>Constant Types</strong>: Must be valid type identifiers</li>
<li><strong>String Data</strong>: Must be valid UTF-8</li>
<li><strong>Offsets</strong>: Must be within section bounds</li>
</ol>
<h2 id="example-bytecode-file"><a class="header" href="#example-bytecode-file">Example Bytecode File</a></h2>
<p>Here’s a simple “Hello, World!” program in bytecode format:</p>
<h3 id="source-code"><a class="header" href="#source-code">Source Code</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, World!");
}</code></pre></pre>
<h3 id="bytecode-hexdump"><a class="header" href="#bytecode-hexdump">Bytecode Hexdump</a></h3>
<pre><code>00000000: 444f 5456 0001 0100 0000 0000 0000 0000  DOTV............
00000010: 0000 0000 0000 0040 0000 0000 0000 0020  .......@.......
00000020: 0000 0000 0000 0060 0000 0000 0000 0030  .......`......0
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0004 1001 0000 a001 1100            ............

; Header breakdown:
; 444f5456 - Magic "DOTV"
; 0001 - Version 0.1
; 01 - Arch64
; 00 - No flags
; 0000000000000000 - Entry point 0
; 0000000000000040 - Code section at offset 0x40
; 0000000000000020 - Code section size 32 bytes
; 0000000000000060 - Data section at offset 0x60
; 0000000000000030 - Data section size 48 bytes

; Code section:
; 00000004 - 4 instructions
; 10 01 0000 - PUSH constant 0
; a0 01 - SYSCALL_PRINT
; 11 00 - POP
; 00 - HALT
</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="file-size-optimization"><a class="header" href="#file-size-optimization">File Size Optimization</a></h3>
<ol>
<li><strong>Constant Deduplication</strong>: Reuse identical constants</li>
<li><strong>String Interning</strong>: Share common strings</li>
<li><strong>Instruction Packing</strong>: Use minimal operand sizes</li>
<li><strong>Compression</strong>: Enable compression flag for large files</li>
</ol>
<h3 id="loading-performance"><a class="header" href="#loading-performance">Loading Performance</a></h3>
<ol>
<li><strong>Memory Mapping</strong>: Use memory-mapped files for large bytecode</li>
<li><strong>Lazy Loading</strong>: Load sections on demand</li>
<li><strong>Caching</strong>: Cache parsed bytecode in memory</li>
<li><strong>Validation</strong>: Minimize validation overhead</li>
</ol>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<ol>
<li><strong>Signature Verification</strong>: Verify digital signatures</li>
<li><strong>Bounds Checking</strong>: Validate all offsets and sizes</li>
<li><strong>Instruction Validation</strong>: Verify instruction sequences</li>
<li><strong>Resource Limits</strong>: Enforce memory and execution limits</li>
</ol>
<h2 id="tools-and-utilities"><a class="header" href="#tools-and-utilities">Tools and Utilities</a></h2>
<h3 id="bytecode-inspector"><a class="header" href="#bytecode-inspector">Bytecode Inspector</a></h3>
<pre><code class="language-bash">dotvm inspect program.dotvm
</code></pre>
<h3 id="bytecode-disassembler"><a class="header" href="#bytecode-disassembler">Bytecode Disassembler</a></h3>
<pre><code class="language-bash">dotvm disasm program.dotvm &gt; program.asm
</code></pre>
<h3 id="bytecode-validator"><a class="header" href="#bytecode-validator">Bytecode Validator</a></h3>
<pre><code class="language-bash">dotvm validate program.dotvm
</code></pre>
<h3 id="bytecode-optimizer"><a class="header" href="#bytecode-optimizer">Bytecode Optimizer</a></h3>
<pre><code class="language-bash">dotvm optimize input.dotvm output.dotvm
</code></pre>
<h2 id="version-history"><a class="header" href="#version-history">Version History</a></h2>
<h3 id="version-01-current"><a class="header" href="#version-01-current">Version 0.1 (Current)</a></h3>
<ul>
<li>Initial bytecode format</li>
<li>Basic instruction set support</li>
<li>Debug information support</li>
<li>Architecture-specific encoding</li>
</ul>
<h3 id="future-versions"><a class="header" href="#future-versions">Future Versions</a></h3>
<ul>
<li><strong>0.2</strong>: Compression support</li>
<li><strong>0.3</strong>: Encryption and signing</li>
<li><strong>0.4</strong>: Extended instruction set</li>
<li><strong>1.0</strong>: Stable format specification</li>
</ul>
<p>For more information about creating and working with bytecode, see the <a href="dotvm/architecture/../usage/transpilation.html">Transpilation Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paracontracts"><a class="header" href="#paracontracts">ParaContracts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h1>
<p>This guide covers the fundamental operations you can perform with DotVM, from basic program execution to common development workflows.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>Before diving into basic operations, ensure you have DotVM installed and configured. See the <a href="dotvm/usage/../../getting-started/installation.html">Installation Guide</a> for setup instructions.</p>
<h3 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h3>
<pre><code class="language-bash"># Check DotVM version
dotvm --version

# Check available commands
dotvm --help
</code></pre>
<h2 id="basic-workflow"><a class="header" href="#basic-workflow">Basic Workflow</a></h2>
<p>The typical DotVM workflow involves three main steps:</p>
<ol>
<li><strong>Write Rust Code</strong>: Create your application in Rust</li>
<li><strong>Transpile to Bytecode</strong>: Convert Rust to DotVM bytecode</li>
<li><strong>Execute Bytecode</strong>: Run the bytecode on DotVM</li>
</ol>
<h3 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h3>
<p><strong>Step 1: Create a Rust program</strong></p>
<pre><pre class="playground"><code class="language-rust">// hello.rs
fn main() {
    println!("Hello, DotVM!");
    let x = 10;
    let y = 5;
    let result = x + y;
    println!("Result: {}", result);
}</code></pre></pre>
<p><strong>Step 2: Transpile to bytecode</strong></p>
<pre><code class="language-bash">dotvm transpile -i hello.rs -o hello.dotvm
</code></pre>
<p><strong>Step 3: Execute the bytecode</strong></p>
<pre><code class="language-bash">dotvm run hello.dotvm
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>Hello, DotVM!
Result: 15
Execution completed!
Instructions executed: 42
Execution time: 1.2ms
Total time: 2.1ms
</code></pre>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<h3 id="working-with-different-architectures"><a class="header" href="#working-with-different-architectures">Working with Different Architectures</a></h3>
<p>DotVM supports multiple architectures. Choose based on your needs:</p>
<p><strong>64-bit (Default):</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm -a arch64
</code></pre>
<p><strong>256-bit (Blockchain/Crypto):</strong></p>
<pre><code class="language-bash">dotvm transpile -i crypto_app.rs -o crypto_app.dotvm -a arch256
</code></pre>
<p><strong>128-bit (Scientific Computing):</strong></p>
<pre><code class="language-bash">dotvm transpile -i scientific.rs -o scientific.dotvm -a arch128
</code></pre>
<h3 id="optimization-levels"><a class="header" href="#optimization-levels">Optimization Levels</a></h3>
<p>Control compilation optimization:</p>
<p><strong>Development (Fast compilation):</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --opt-level 0
</code></pre>
<p><strong>Production (Balanced):</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --opt-level 2
</code></pre>
<p><strong>Maximum Performance:</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --opt-level 3
</code></pre>
<h3 id="debug-mode-1"><a class="header" href="#debug-mode-1">Debug Mode</a></h3>
<p>Enable debugging for development:</p>
<p><strong>Compile with debug info:</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --debug
</code></pre>
<p><strong>Run with debugging:</strong></p>
<pre><code class="language-bash">dotvm run program.dotvm --debug
</code></pre>
<p><strong>Step-by-step execution:</strong></p>
<pre><code class="language-bash">dotvm run program.dotvm --step
</code></pre>
<h2 id="working-with-functions"><a class="header" href="#working-with-functions">Working with Functions</a></h2>
<h3 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h3>
<pre><pre class="playground"><code class="language-rust">// functions.rs
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn multiply(a: i32, b: i32) -&gt; i32 {
    a * b
}

fn main() {
    let x = 10;
    let y = 5;
    
    let sum = add(x, y);
    let product = multiply(x, y);
    
    println!("Sum: {}", sum);
    println!("Product: {}", product);
}</code></pre></pre>
<h3 id="recursive-functions"><a class="header" href="#recursive-functions">Recursive Functions</a></h3>
<pre><pre class="playground"><code class="language-rust">// fibonacci.rs
fn fibonacci(n: u32) -&gt; u64 {
    match n {
        0 =&gt; 0,
        1 =&gt; 1,
        _ =&gt; fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn main() {
    for i in 0..10 {
        println!("fibonacci({}) = {}", i, fibonacci(i));
    }
}</code></pre></pre>
<h2 id="control-flow-1"><a class="header" href="#control-flow-1">Control Flow</a></h2>
<h3 id="conditional-statements"><a class="header" href="#conditional-statements">Conditional Statements</a></h3>
<pre><pre class="playground"><code class="language-rust">// conditions.rs
fn main() {
    let number = 42;
    
    if number &gt; 0 {
        println!("Positive number");
    } else if number &lt; 0 {
        println!("Negative number");
    } else {
        println!("Zero");
    }
    
    // Match expressions
    match number {
        0 =&gt; println!("Zero"),
        1..=10 =&gt; println!("Small positive"),
        11..=100 =&gt; println!("Medium positive"),
        _ =&gt; println!("Large positive"),
    }
}</code></pre></pre>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<pre><pre class="playground"><code class="language-rust">// loops.rs
fn main() {
    // For loop
    for i in 1..=5 {
        println!("Count: {}", i);
    }
    
    // While loop
    let mut counter = 0;
    while counter &lt; 3 {
        println!("Counter: {}", counter);
        counter += 1;
    }
    
    // Loop with break
    let mut value = 0;
    loop {
        value += 1;
        if value &gt; 5 {
            break;
        }
        println!("Value: {}", value);
    }
}</code></pre></pre>
<h2 id="data-types-and-structures"><a class="header" href="#data-types-and-structures">Data Types and Structures</a></h2>
<h3 id="basic-data-types"><a class="header" href="#basic-data-types">Basic Data Types</a></h3>
<pre><pre class="playground"><code class="language-rust">// data_types.rs
fn main() {
    // Integers
    let small: i32 = 42;
    let large: i64 = 1_000_000;
    
    // Floating point
    let pi: f64 = 3.14159;
    
    // Boolean
    let is_true: bool = true;
    
    // String
    let message: String = "Hello, DotVM!".to_string();
    let slice: &amp;str = "String slice";
    
    println!("Integer: {}", small);
    println!("Float: {}", pi);
    println!("Boolean: {}", is_true);
    println!("String: {}", message);
}</code></pre></pre>
<h3 id="collections"><a class="header" href="#collections">Collections</a></h3>
<pre><pre class="playground"><code class="language-rust">// collections.rs
fn main() {
    // Vector
    let mut numbers = vec![1, 2, 3, 4, 5];
    numbers.push(6);
    
    for num in &amp;numbers {
        println!("Number: {}", num);
    }
    
    // Array
    let array: [i32; 5] = [1, 2, 3, 4, 5];
    println!("Array length: {}", array.len());
    
    // Tuple
    let tuple: (i32, f64, &amp;str) = (42, 3.14, "hello");
    println!("Tuple: {:?}", tuple);
}</code></pre></pre>
<h3 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and Enums</a></h3>
<pre><pre class="playground"><code class="language-rust">// structs_enums.rs
#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

#[derive(Debug)]
enum Color {
    Red,
    Green,
    Blue,
    RGB(u8, u8, u8),
}

fn main() {
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
    };
    
    let color = Color::RGB(255, 0, 0);
    
    println!("Person: {:?}", person);
    println!("Color: {:?}", color);
}</code></pre></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<h3 id="result-type"><a class="header" href="#result-type">Result Type</a></h3>
<pre><pre class="playground"><code class="language-rust">// error_handling.rs
fn divide(a: f64, b: f64) -&gt; Result&lt;f64, String&gt; {
    if b == 0.0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(10.0, 2.0) {
        Ok(result) =&gt; println!("Result: {}", result),
        Err(error) =&gt; println!("Error: {}", error),
    }
    
    match divide(10.0, 0.0) {
        Ok(result) =&gt; println!("Result: {}", result),
        Err(error) =&gt; println!("Error: {}", error),
    }
}</code></pre></pre>
<h2 id="performance-monitoring"><a class="header" href="#performance-monitoring">Performance Monitoring</a></h2>
<h3 id="timing-execution"><a class="header" href="#timing-execution">Timing Execution</a></h3>
<pre><code class="language-bash"># Basic timing
time dotvm run program.dotvm

# Detailed performance info
dotvm run program.dotvm --verbose
</code></pre>
<h3 id="comparing-optimizations"><a class="header" href="#comparing-optimizations">Comparing Optimizations</a></h3>
<pre><code class="language-bash"># No optimization
dotvm transpile -i program.rs -o program_o0.dotvm --opt-level 0
time dotvm run program_o0.dotvm

# Maximum optimization
dotvm transpile -i program.rs -o program_o3.dotvm --opt-level 3
time dotvm run program_o3.dotvm
</code></pre>
<h2 id="file-io-operations"><a class="header" href="#file-io-operations">File I/O Operations</a></h2>
<h3 id="reading-and-writing-files"><a class="header" href="#reading-and-writing-files">Reading and Writing Files</a></h3>
<pre><pre class="playground"><code class="language-rust">// file_io.rs
use std::fs;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Write to file
    let content = "Hello, DotVM file I/O!";
    fs::write("output.txt", content)?;
    
    // Read from file
    let read_content = fs::read_to_string("output.txt")?;
    println!("File content: {}", read_content);
    
    Ok(())
}</code></pre></pre>
<h2 id="memory-management-1"><a class="header" href="#memory-management-1">Memory Management</a></h2>
<h3 id="understanding-stack-usage"><a class="header" href="#understanding-stack-usage">Understanding Stack Usage</a></h3>
<pre><pre class="playground"><code class="language-rust">// memory.rs
fn recursive_function(depth: u32) {
    if depth &gt; 0 {
        println!("Depth: {}", depth);
        recursive_function(depth - 1);
    }
}

fn main() {
    // Monitor stack usage with debug mode
    recursive_function(10);
}</code></pre></pre>
<p><strong>Run with memory monitoring:</strong></p>
<pre><code class="language-bash">dotvm run memory.dotvm --debug --verbose
</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="code-organization"><a class="header" href="#code-organization">Code Organization</a></h3>
<ol>
<li><strong>Keep functions focused</strong>: Write small, single-purpose functions</li>
<li><strong>Use meaningful names</strong>: Choose descriptive variable and function names</li>
<li><strong>Handle errors properly</strong>: Use Result types for error handling</li>
<li><strong>Comment complex logic</strong>: Add comments for non-obvious code</li>
</ol>
<h3 id="performance-tips-2"><a class="header" href="#performance-tips-2">Performance Tips</a></h3>
<ol>
<li><strong>Choose appropriate architecture</strong>: Match architecture to your data needs</li>
<li><strong>Use optimization levels</strong>: Enable optimizations for production code</li>
<li><strong>Profile your code</strong>: Use verbose mode to identify bottlenecks</li>
<li><strong>Minimize allocations</strong>: Reuse data structures when possible</li>
</ol>
<h3 id="debugging-workflow"><a class="header" href="#debugging-workflow">Debugging Workflow</a></h3>
<ol>
<li><strong>Start with debug mode</strong>: Use <code>--debug</code> flag during development</li>
<li><strong>Use step mode</strong>: Step through code with <code>--step</code> for detailed debugging</li>
<li><strong>Check verbose output</strong>: Use <code>--verbose</code> for detailed execution information</li>
<li><strong>Validate bytecode</strong>: Ensure bytecode is generated correctly</li>
</ol>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="configuration-pattern"><a class="header" href="#configuration-pattern">Configuration Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust">// config.rs
struct Config {
    debug: bool,
    max_iterations: u32,
    output_file: String,
}

impl Config {
    fn new() -&gt; Self {
        Config {
            debug: false,
            max_iterations: 1000,
            output_file: "output.txt".to_string(),
        }
    }
}

fn main() {
    let config = Config::new();
    println!("Debug mode: {}", config.debug);
    println!("Max iterations: {}", config.max_iterations);
}</code></pre></pre>
<h3 id="iterator-pattern"><a class="header" href="#iterator-pattern">Iterator Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust">// iterators.rs
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // Map and collect
    let doubled: Vec&lt;i32&gt; = numbers.iter().map(|x| x * 2).collect();
    println!("Doubled: {:?}", doubled);
    
    // Filter and sum
    let sum: i32 = numbers.iter().filter(|&amp;&amp;x| x &gt; 2).sum();
    println!("Sum of numbers &gt; 2: {}", sum);
}</code></pre></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>After mastering basic operations, explore:</p>
<ol>
<li><strong><a href="dotvm/usage/transpilation.html">Transpilation Guide</a></strong>: Advanced transpilation techniques</li>
<li><strong><a href="dotvm/usage/execution.html">Execution Guide</a></strong>: Advanced execution and debugging</li>
<li><strong><a href="dotvm/usage/advanced-features.html">Advanced Features</a></strong>: Complex DotVM capabilities</li>
<li><strong><a href="dotvm/usage/../../dotdb/usage/basic-operations.html">DotDB Integration</a></strong>: Database operations</li>
</ol>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h3>
<p><strong>Compilation Errors:</strong></p>
<ul>
<li>Check Rust syntax and ensure code compiles with <code>rustc</code></li>
<li>Verify all dependencies are available</li>
</ul>
<p><strong>Execution Errors:</strong></p>
<ul>
<li>Use <code>--debug</code> mode to see detailed execution information</li>
<li>Check for stack overflow with recursive functions</li>
<li>Verify bytecode file exists and is not corrupted</li>
</ul>
<p><strong>Performance Issues:</strong></p>
<ul>
<li>Try different optimization levels</li>
<li>Use <code>--verbose</code> to identify bottlenecks</li>
<li>Consider different VM architectures for your use case</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transpilation-guide"><a class="header" href="#transpilation-guide">Transpilation Guide</a></h1>
<p>This guide covers the complete process of transpiling Rust source code to DotVM bytecode, including optimization strategies, debugging techniques, and advanced features.</p>
<h2 id="transpilation-overview"><a class="header" href="#transpilation-overview">Transpilation Overview</a></h2>
<p>The DotVM transpilation process converts Rust source code to DotVM bytecode through a multi-stage pipeline:</p>
<pre><code>Rust Source Code
       ↓
   Rust Compiler (rustc)
       ↓
   WebAssembly (WASM)
       ↓
   WASM Parser
       ↓
   DotVM Translator
       ↓
   Architecture Optimizer
       ↓
   DotVM Bytecode
</code></pre>
<h2 id="basic-transpilation"><a class="header" href="#basic-transpilation">Basic Transpilation</a></h2>
<h3 id="simple-example-1"><a class="header" href="#simple-example-1">Simple Example</a></h3>
<p>Let’s start with a basic Rust program:</p>
<pre><pre class="playground"><code class="language-rust">// hello.rs
fn main() {
    println!("Hello, DotVM!");
    let result = add_numbers(10, 5);
    println!("Result: {}", result);
}

fn add_numbers(a: i32, b: i32) -&gt; i32 {
    a + b
}</code></pre></pre>
<p><strong>Transpile to bytecode:</strong></p>
<pre><code class="language-bash">dotvm transpile -i hello.rs -o hello.dotvm
</code></pre>
<p><strong>Execute the bytecode:</strong></p>
<pre><code class="language-bash">dotvm run hello.dotvm
</code></pre>
<h3 id="command-line-options"><a class="header" href="#command-line-options">Command Line Options</a></h3>
<p>The <code>dotvm transpile</code> command supports various options:</p>
<pre><code class="language-bash">dotvm transpile [OPTIONS] --input &lt;INPUT&gt; --output &lt;OUTPUT&gt;
</code></pre>
<p><strong>Required Options:</strong></p>
<ul>
<li><code>-i, --input &lt;INPUT&gt;</code>: Input Rust source file or project directory</li>
<li><code>-o, --output &lt;OUTPUT&gt;</code>: Output DotVM bytecode file</li>
</ul>
<p><strong>Optional Parameters:</strong></p>
<ul>
<li><code>-a, --architecture &lt;ARCH&gt;</code>: Target architecture (arch32, arch64, arch128, arch256, arch512)</li>
<li><code>--opt-level &lt;LEVEL&gt;</code>: Optimization level (0-3)</li>
<li><code>--debug</code>: Include debug information</li>
<li><code>-v, --verbose</code>: Verbose output</li>
<li><code>--keep-intermediate</code>: Keep intermediate WASM files</li>
<li><code>--target-dir &lt;DIR&gt;</code>: Custom target directory for Rust compilation</li>
</ul>
<h2 id="architecture-selection-1"><a class="header" href="#architecture-selection-1">Architecture Selection</a></h2>
<h3 id="choosing-the-right-architecture"><a class="header" href="#choosing-the-right-architecture">Choosing the Right Architecture</a></h3>
<p>Select the architecture based on your application’s requirements:</p>
<p><strong>Arch64 (Default):</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm -a arch64
</code></pre>
<ul>
<li><strong>Best for</strong>: General-purpose applications</li>
<li><strong>Word size</strong>: 64 bits</li>
<li><strong>Memory</strong>: Up to 16 EB addressable</li>
<li><strong>Performance</strong>: Balanced</li>
</ul>
<p><strong>Arch256 (Blockchain):</strong></p>
<pre><code class="language-bash">dotvm transpile -i crypto_app.rs -o crypto_app.dotvm -a arch256
</code></pre>
<ul>
<li><strong>Best for</strong>: Cryptocurrency and blockchain applications</li>
<li><strong>Word size</strong>: 256 bits</li>
<li><strong>Features</strong>: Native 256-bit integer support</li>
<li><strong>Use cases</strong>: Smart contracts, cryptographic operations</li>
</ul>
<p><strong>Arch128 (Scientific):</strong></p>
<pre><code class="language-bash">dotvm transpile -i simulation.rs -o simulation.dotvm -a arch128
</code></pre>
<ul>
<li><strong>Best for</strong>: Scientific computing, high-precision calculations</li>
<li><strong>Word size</strong>: 128 bits</li>
<li><strong>Features</strong>: Extended precision arithmetic</li>
<li><strong>Use cases</strong>: Mathematical simulations, financial calculations</li>
</ul>
<h3 id="architecture-specific-considerations"><a class="header" href="#architecture-specific-considerations">Architecture-Specific Considerations</a></h3>
<p><strong>Data Type Mapping:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Rust Type</th><th>Arch32</th><th>Arch64</th><th>Arch128</th><th>Arch256</th><th>Arch512</th></tr></thead><tbody>
<tr><td><code>i32</code></td><td>Native</td><td>Promoted</td><td>Promoted</td><td>Promoted</td><td>Promoted</td></tr>
<tr><td><code>i64</code></td><td>Emulated</td><td>Native</td><td>Promoted</td><td>Promoted</td><td>Promoted</td></tr>
<tr><td><code>i128</code></td><td>Emulated</td><td>Emulated</td><td>Native</td><td>Promoted</td><td>Promoted</td></tr>
<tr><td><code>usize</code></td><td>32-bit</td><td>64-bit</td><td>128-bit</td><td>256-bit</td><td>512-bit</td></tr>
</tbody></table>
</div>
<h2 id="optimization-levels-1"><a class="header" href="#optimization-levels-1">Optimization Levels</a></h2>
<h3 id="optimization-strategies"><a class="header" href="#optimization-strategies">Optimization Strategies</a></h3>
<p>DotVM supports four optimization levels:</p>
<p><strong>Level 0 (No Optimization):</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --opt-level 0
</code></pre>
<ul>
<li><strong>Purpose</strong>: Fastest compilation, debugging</li>
<li><strong>Features</strong>: No optimizations applied</li>
<li><strong>Use cases</strong>: Development, debugging</li>
</ul>
<p><strong>Level 1 (Basic Optimization):</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --opt-level 1
</code></pre>
<ul>
<li><strong>Purpose</strong>: Basic optimizations with fast compilation</li>
<li><strong>Features</strong>: Dead code elimination, basic constant folding</li>
<li><strong>Use cases</strong>: Development builds with some optimization</li>
</ul>
<p><strong>Level 2 (Standard Optimization - Default):</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --opt-level 2
</code></pre>
<ul>
<li><strong>Purpose</strong>: Good balance of compilation time and performance</li>
<li><strong>Features</strong>: Advanced optimizations, inlining, loop optimizations</li>
<li><strong>Use cases</strong>: Production builds, general use</li>
</ul>
<p><strong>Level 3 (Maximum Optimization):</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --opt-level 3
</code></pre>
<ul>
<li><strong>Purpose</strong>: Maximum performance</li>
<li><strong>Features</strong>: Aggressive optimizations, vectorization</li>
<li><strong>Use cases</strong>: Performance-critical applications</li>
</ul>
<h3 id="optimization-examples"><a class="header" href="#optimization-examples">Optimization Examples</a></h3>
<p><strong>Performance Comparison:</strong></p>
<pre><pre class="playground"><code class="language-rust">// fibonacci.rs
fn fibonacci(n: u32) -&gt; u64 {
    match n {
        0 =&gt; 0,
        1 =&gt; 1,
        _ =&gt; fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn main() {
    let result = fibonacci(30);
    println!("Fibonacci(30) = {}", result);
}</code></pre></pre>
<p><strong>Compile with different optimization levels:</strong></p>
<pre><code class="language-bash"># No optimization
dotvm transpile -i fibonacci.rs -o fib_o0.dotvm --opt-level 0
time dotvm run fib_o0.dotvm

# Maximum optimization
dotvm transpile -i fibonacci.rs -o fib_o3.dotvm --opt-level 3
time dotvm run fib_o3.dotvm
</code></pre>
<h2 id="debug-information"><a class="header" href="#debug-information">Debug Information</a></h2>
<h3 id="including-debug-information"><a class="header" href="#including-debug-information">Including Debug Information</a></h3>
<p>Enable debug information for better debugging experience:</p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --debug --verbose
</code></pre>
<p><strong>Debug information includes:</strong></p>
<ul>
<li>Source code mapping</li>
<li>Function names and locations</li>
<li>Variable names and scopes</li>
<li>Line number information</li>
</ul>
<h3 id="debugging-transpiled-code"><a class="header" href="#debugging-transpiled-code">Debugging Transpiled Code</a></h3>
<p><strong>Step-by-step execution:</strong></p>
<pre><code class="language-bash">dotvm run program.dotvm --debug --step
</code></pre>
<p><strong>Debug output example:</strong></p>
<pre><code>[DEBUG] Loading bytecode: program.dotvm
[DEBUG] Architecture: Arch64
[DEBUG] Entry point: 0x0000000000000000
[DEBUG] Executing instruction at 0x00000000: PUSH 0x00000001
[DEBUG] Stack: [1]
[DEBUG] Executing instruction at 0x00000004: PUSH 0x00000002
[DEBUG] Stack: [1, 2]
[DEBUG] Executing instruction at 0x00000008: ADD
[DEBUG] Stack: [3]
</code></pre>
<h2 id="advanced-transpilation-features"><a class="header" href="#advanced-transpilation-features">Advanced Transpilation Features</a></h2>
<h3 id="project-transpilation"><a class="header" href="#project-transpilation">Project Transpilation</a></h3>
<p>Transpile entire Rust projects:</p>
<pre><code class="language-bash"># Transpile a Cargo project
dotvm transpile -i ./my_project -o my_project.dotvm --target-dir ./target
</code></pre>
<p><strong>Project structure:</strong></p>
<pre><code>my_project/
├── Cargo.toml
├── src/
│   ├── main.rs
│   ├── lib.rs
│   └── modules/
│       ├── mod.rs
│       └── utils.rs
└── target/          # Build artifacts
</code></pre>
<h3 id="custom-target-directory"><a class="header" href="#custom-target-directory">Custom Target Directory</a></h3>
<p>Use a custom target directory for Rust compilation:</p>
<pre><code class="language-bash">dotvm transpile -i project.rs -o project.dotvm --target-dir /tmp/dotvm_build
</code></pre>
<h3 id="keeping-intermediate-files"><a class="header" href="#keeping-intermediate-files">Keeping Intermediate Files</a></h3>
<p>Keep intermediate WASM files for analysis:</p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --keep-intermediate
</code></pre>
<p><strong>Generated files:</strong></p>
<pre><code>program.rs          # Original source
program.wasm        # Intermediate WASM
program.dotvm       # Final bytecode
</code></pre>
<h2 id="error-handling-and-troubleshooting"><a class="header" href="#error-handling-and-troubleshooting">Error Handling and Troubleshooting</a></h2>
<h3 id="common-transpilation-errors"><a class="header" href="#common-transpilation-errors">Common Transpilation Errors</a></h3>
<p><strong>Rust Compilation Errors:</strong></p>
<pre><code class="language-bash">error[E0425]: cannot find value `undefined_variable` in this scope
 --&gt; src/main.rs:3:13
  |
3 |     println!("{}", undefined_variable);
  |             ^^^^^^^^^^^^^^^^^^^ not found in this scope
</code></pre>
<p><strong>Solution:</strong> Fix Rust compilation errors first.</p>
<p><strong>WASM Parsing Errors:</strong></p>
<pre><code>Error: Failed to parse WebAssembly module
Caused by: Invalid WASM magic number
</code></pre>
<p><strong>Solution:</strong> Ensure Rust code compiles to valid WebAssembly.</p>
<p><strong>Translation Errors:</strong></p>
<pre><code>Error: Unsupported WASM instruction: unreachable
</code></pre>
<p><strong>Solution:</strong> Avoid unsupported Rust features or WASM instructions.</p>
<h3 id="debugging-transpilation-issues"><a class="header" href="#debugging-transpilation-issues">Debugging Transpilation Issues</a></h3>
<p><strong>Verbose Output:</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --verbose
</code></pre>
<p><strong>Check Intermediate WASM:</strong></p>
<pre><code class="language-bash">dotvm transpile -i program.rs -o program.dotvm --keep-intermediate
wasm-objdump -d program.wasm  # Inspect WASM
</code></pre>
<p><strong>Validate Bytecode:</strong></p>
<pre><code class="language-bash">dotvm validate program.dotvm
</code></pre>
<h2 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h2>
<h3 id="rust-code-optimization"><a class="header" href="#rust-code-optimization">Rust Code Optimization</a></h3>
<p><strong>Optimize Rust source for better transpilation:</strong></p>
<pre><pre class="playground"><code class="language-rust">// Use appropriate data types
fn efficient_calculation(data: &amp;[i32]) -&gt; i32 {
    // Use iterators for better optimization
    data.iter().sum()
}

// Avoid unnecessary allocations
fn process_string(s: &amp;str) -&gt; String {
    // Use string slices when possible
    s.to_uppercase()
}

// Use const for compile-time constants
const BUFFER_SIZE: usize = 1024;

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let result = efficient_calculation(&amp;data);
    println!("Result: {}", result);
}</code></pre></pre>
<h3 id="architecture-specific-optimization"><a class="header" href="#architecture-specific-optimization">Architecture-Specific Optimization</a></h3>
<p><strong>Optimize for target architecture:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For Arch256 (blockchain applications)
fn hash_calculation(data: &amp;[u8]) -&gt; [u8; 32] {
    // Use 256-bit operations
    use sha2::{Sha256, Digest};
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().into()
}

// For Arch128 (scientific computing)
fn high_precision_calculation(a: f64, b: f64) -&gt; f64 {
    // Use high-precision arithmetic
    (a * b).sqrt()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="compilation-flags"><a class="header" href="#compilation-flags">Compilation Flags</a></h3>
<p><strong>Optimize Rust compilation:</strong></p>
<pre><code class="language-bash"># Create optimized WASM
export RUSTFLAGS="-C target-cpu=native -C opt-level=3"
dotvm transpile -i program.rs -o program.dotvm --opt-level 3
</code></pre>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="database-integration-1"><a class="header" href="#database-integration-1">Database Integration</a></h3>
<pre><pre class="playground"><code class="language-rust">// database_app.rs
fn main() {
    // This will use DotDB opcodes in the generated bytecode
    store_user_data("alice", 30);
    let age = get_user_age("alice");
    println!("Alice's age: {}", age);
}

fn store_user_data(name: &amp;str, age: u32) {
    // In the transpiled bytecode, this becomes DB_PUT operations
    println!("Storing user: {} age: {}", name, age);
}

fn get_user_age(name: &amp;str) -&gt; u32 {
    // In the transpiled bytecode, this becomes DB_GET operations
    println!("Getting age for user: {}", name);
    30 // Placeholder
}</code></pre></pre>
<p><strong>Transpile and run:</strong></p>
<pre><code class="language-bash">dotvm transpile -i database_app.rs -o database_app.dotvm
dotvm run database_app.dotvm --verbose
</code></pre>
<h3 id="cryptographic-operations-1"><a class="header" href="#cryptographic-operations-1">Cryptographic Operations</a></h3>
<pre><pre class="playground"><code class="language-rust">// crypto_app.rs
use sha2::{Sha256, Digest};

fn main() {
    let data = b"Hello, DotVM!";
    let hash = calculate_hash(data);
    println!("Hash: {:?}", hash);
}

fn calculate_hash(data: &amp;[u8]) -&gt; [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().into()
}</code></pre></pre>
<p><strong>Transpile for blockchain architecture:</strong></p>
<pre><code class="language-bash">dotvm transpile -i crypto_app.rs -o crypto_app.dotvm -a arch256 --opt-level 3
</code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<h3 id="code-organization-1"><a class="header" href="#code-organization-1">Code Organization</a></h3>
<ol>
<li><strong>Modular Design</strong>: Organize code into logical modules</li>
<li><strong>Function Size</strong>: Keep functions reasonably sized for better optimization</li>
<li><strong>Data Structures</strong>: Use appropriate data structures for your use case</li>
<li><strong>Error Handling</strong>: Implement proper error handling</li>
</ol>
<h3 id="performance-guidelines"><a class="header" href="#performance-guidelines">Performance Guidelines</a></h3>
<ol>
<li><strong>Choose Appropriate Architecture</strong>: Match architecture to your data requirements</li>
<li><strong>Optimize Hot Paths</strong>: Focus optimization on frequently executed code</li>
<li><strong>Profile Performance</strong>: Use timing and profiling tools</li>
<li><strong>Test Different Optimization Levels</strong>: Compare performance across optimization levels</li>
</ol>
<h3 id="development-workflow-1"><a class="header" href="#development-workflow-1">Development Workflow</a></h3>
<ol>
<li><strong>Start with Arch64</strong>: Use default architecture for development</li>
<li><strong>Enable Debug Information</strong>: Use <code>--debug</code> during development</li>
<li><strong>Incremental Testing</strong>: Test transpilation frequently during development</li>
<li><strong>Performance Testing</strong>: Benchmark critical code paths</li>
</ol>
<h2 id="automation-and-scripting"><a class="header" href="#automation-and-scripting">Automation and Scripting</a></h2>
<h3 id="build-scripts"><a class="header" href="#build-scripts">Build Scripts</a></h3>
<p>Create build scripts for automated transpilation:</p>
<pre><code class="language-bash">#!/bin/bash
# build.sh

set -e

echo "Building DotVM bytecode..."

# Clean previous builds
rm -f *.dotvm

# Transpile for different architectures
dotvm transpile -i src/main.rs -o app_64.dotvm -a arch64 --opt-level 2
dotvm transpile -i src/main.rs -o app_256.dotvm -a arch256 --opt-level 2

# Validate bytecode
dotvm validate app_64.dotvm
dotvm validate app_256.dotvm

echo "Build complete!"
</code></pre>
<h3 id="makefile-example"><a class="header" href="#makefile-example">Makefile Example</a></h3>
<pre><code class="language-makefile"># Makefile for DotVM projects

RUST_SRC = src/main.rs
BYTECODE_64 = app_64.dotvm
BYTECODE_256 = app_256.dotvm

.PHONY: all clean test

all: $(BYTECODE_64) $(BYTECODE_256)

$(BYTECODE_64): $(RUST_SRC)
	dotvm transpile -i $(RUST_SRC) -o $(BYTECODE_64) -a arch64 --opt-level 2

$(BYTECODE_256): $(RUST_SRC)
	dotvm transpile -i $(RUST_SRC) -o $(BYTECODE_256) -a arch256 --opt-level 2

test: $(BYTECODE_64)
	dotvm run $(BYTECODE_64) --verbose

clean:
	rm -f *.dotvm *.wasm

debug: $(RUST_SRC)
	dotvm transpile -i $(RUST_SRC) -o debug.dotvm --debug --opt-level 0
	dotvm run debug.dotvm --debug --step
</code></pre>
<p>For more information about executing bytecode, see the <a href="dotvm/usage/execution.html">Execution Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-guide"><a class="header" href="#execution-guide">Execution Guide</a></h1>
<p>This guide covers executing DotVM bytecode, including runtime options, debugging techniques, performance monitoring, and advanced execution features.</p>
<h2 id="basic-execution"><a class="header" href="#basic-execution">Basic Execution</a></h2>
<h3 id="running-bytecode"><a class="header" href="#running-bytecode">Running Bytecode</a></h3>
<p>The simplest way to execute DotVM bytecode:</p>
<pre><code class="language-bash">dotvm run program.dotvm
</code></pre>
<p><strong>Example output:</strong></p>
<pre><code>Execution completed!
Instructions executed: 1234
Execution time: 15.2ms
Total time: 18.7ms
</code></pre>
<h3 id="command-line-options-1"><a class="header" href="#command-line-options-1">Command Line Options</a></h3>
<p>The <code>dotvm run</code> command supports various execution options:</p>
<pre><code class="language-bash">dotvm run [OPTIONS] &lt;BYTECODE_FILE&gt;
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>&lt;BYTECODE_FILE&gt;</code>: Path to the bytecode file (required)</li>
<li><code>-d, --debug</code>: Enable debug mode</li>
<li><code>-s, --step</code>: Enable step-by-step execution</li>
<li><code>--max-instructions &lt;NUM&gt;</code>: Maximum instruction limit (default: 1,000,000)</li>
<li><code>-v, --verbose</code>: Verbose output</li>
</ul>
<h2 id="debug-mode-2"><a class="header" href="#debug-mode-2">Debug Mode</a></h2>
<h3 id="enabling-debug-mode"><a class="header" href="#enabling-debug-mode">Enabling Debug Mode</a></h3>
<p>Debug mode provides detailed execution information:</p>
<pre><code class="language-bash">dotvm run program.dotvm --debug
</code></pre>
<p><strong>Debug output includes:</strong></p>
<ul>
<li>Instruction-by-instruction execution</li>
<li>Stack state after each operation</li>
<li>Memory access patterns</li>
<li>Function calls and returns</li>
<li>Error details</li>
</ul>
<p><strong>Example debug output:</strong></p>
<pre><code>[DEBUG] Loading bytecode: program.dotvm
[DEBUG] Architecture: Arch64, Entry point: 0x0000000000000000
[DEBUG] Starting execution...

[0x00000000] PUSH 0x00000001          Stack: [1]
[0x00000004] PUSH 0x00000002          Stack: [1, 2]
[0x00000008] ADD                      Stack: [3]
[0x00000009] SYSCALL_PRINT            Stack: []
Output: 3
[0x0000000A] HALT                     Stack: []

[DEBUG] Execution completed
[DEBUG] Instructions executed: 4
[DEBUG] Final stack size: 0
[DEBUG] Program counter: 0x0000000A
[DEBUG] Halted: true
</code></pre>
<h3 id="debug-information-1"><a class="header" href="#debug-information-1">Debug Information</a></h3>
<p>When bytecode includes debug information (compiled with <code>--debug</code>):</p>
<pre><code class="language-bash">dotvm run debug_program.dotvm --debug
</code></pre>
<p><strong>Enhanced debug output:</strong></p>
<pre><code>[DEBUG] Source: main.rs:5:13
[0x00000000] PUSH 0x00000001          // let x = 1;
             Stack: [1]

[DEBUG] Source: main.rs:6:13  
[0x00000004] PUSH 0x00000002          // let y = 2;
             Stack: [1, 2]

[DEBUG] Source: main.rs:7:13
[0x00000008] ADD                      // let result = x + y;
             Stack: [3]
</code></pre>
<h2 id="step-mode-1"><a class="header" href="#step-mode-1">Step Mode</a></h2>
<h3 id="interactive-debugging"><a class="header" href="#interactive-debugging">Interactive Debugging</a></h3>
<p>Step mode allows interactive debugging with manual control:</p>
<pre><code class="language-bash">dotvm run program.dotvm --step
</code></pre>
<p><strong>Interactive session:</strong></p>
<pre><code>[STEP] Press Enter to execute next instruction, 'q' to quit, 'i' for info
[0x00000000] PUSH 0x00000001          Stack: [1]
&gt; [Enter]

[0x00000004] PUSH 0x00000002          Stack: [1, 2]  
&gt; i
Stack: [1, 2]
PC: 0x00000004
Memory usage: 1024 bytes
&gt; [Enter]

[0x00000008] ADD                      Stack: [3]
&gt; q
Execution stopped by user
</code></pre>
<h3 id="step-mode-commands"><a class="header" href="#step-mode-commands">Step Mode Commands</a></h3>
<p>Available commands in step mode:</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Enter</code></td><td>Execute next instruction</td></tr>
<tr><td><code>q</code></td><td>Quit execution</td></tr>
<tr><td><code>i</code></td><td>Show VM state information</td></tr>
<tr><td><code>s</code></td><td>Show stack contents</td></tr>
<tr><td><code>m &lt;addr&gt;</code></td><td>Show memory at address</td></tr>
<tr><td><code>c</code></td><td>Continue execution (exit step mode)</td></tr>
<tr><td><code>h</code></td><td>Show help</td></tr>
</tbody></table>
</div>
<h2 id="verbose-mode"><a class="header" href="#verbose-mode">Verbose Mode</a></h2>
<h3 id="detailed-execution-information"><a class="header" href="#detailed-execution-information">Detailed Execution Information</a></h3>
<p>Verbose mode provides comprehensive execution details:</p>
<pre><code class="language-bash">dotvm run program.dotvm --verbose
</code></pre>
<p><strong>Verbose output:</strong></p>
<pre><code>Loading bytecode from: program.dotvm
Bytecode size: 1024 bytes
Architecture: Arch64
Entry point: 0x0000000000000000
Code section: 512 bytes
Data section: 256 bytes
Debug section: 256 bytes

Bytecode loaded in 1.2ms
Initializing VM...
Stack size: 1MB
Memory pool: 10MB
Database bridge: Connected

Starting execution...
Instruction cache: Enabled
Branch prediction: Enabled
Optimization level: 2

Hello, DotVM!
Result: 42

Execution completed!
Instructions executed: 1,234
Execution time: 15.2ms
Load time: 1.2ms
Total time: 16.4ms

Performance metrics:
- Instructions per second: 81,250
- Memory usage: 2.1MB peak
- Cache hit ratio: 94.2%
- Database operations: 5
</code></pre>
<h2 id="performance-monitoring-1"><a class="header" href="#performance-monitoring-1">Performance Monitoring</a></h2>
<h3 id="execution-statistics"><a class="header" href="#execution-statistics">Execution Statistics</a></h3>
<p>DotVM provides detailed performance statistics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ExecutionResult {
    pub instructions_executed: u64,
    pub execution_time: Duration,
    pub final_stack: Vec&lt;Value&gt;,
    pub pc: u64,
    pub halted: bool,
    pub memory_usage: MemoryStats,
    pub cache_stats: CacheStats,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="timing-analysis"><a class="header" href="#timing-analysis">Timing Analysis</a></h3>
<p><strong>Measure execution performance:</strong></p>
<pre><code class="language-bash"># Basic timing
time dotvm run program.dotvm

# Detailed timing with verbose mode
dotvm run program.dotvm --verbose | grep "time:"
</code></pre>
<p><strong>Performance comparison:</strong></p>
<pre><code class="language-bash"># Compare different architectures
time dotvm run program_64.dotvm   # Arch64
time dotvm run program_256.dotvm  # Arch256

# Compare optimization levels
time dotvm run program_o0.dotvm   # No optimization
time dotvm run program_o3.dotvm   # Maximum optimization
</code></pre>
<h3 id="memory-monitoring"><a class="header" href="#memory-monitoring">Memory Monitoring</a></h3>
<p>Monitor memory usage during execution:</p>
<pre><code class="language-bash"># Run with memory monitoring
dotvm run large_program.dotvm --verbose
</code></pre>
<p><strong>Memory statistics:</strong></p>
<pre><code>Memory Statistics:
- Initial allocation: 10MB
- Peak usage: 45MB
- Final usage: 12MB
- Allocations: 1,234
- Deallocations: 1,200
- Fragmentation: 5.2%
</code></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<h3 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h3>
<p>DotVM provides detailed error information:</p>
<p><strong>Stack overflow:</strong></p>
<pre><code>Error: Stack overflow
  at instruction 0x00001234 (PUSH)
  Stack size: 1048576 bytes (limit reached)
  
Suggestion: Increase stack size or check for infinite recursion
</code></pre>
<p><strong>Division by zero:</strong></p>
<pre><code>Error: Division by zero
  at instruction 0x00000045 (DIV)
  Stack: [10, 0]
  Source: calculator.rs:15:8
  
Suggestion: Add zero-check before division
</code></pre>
<p><strong>Memory access violation:</strong></p>
<pre><code>Error: Invalid memory access
  at instruction 0x00000067 (LOAD)
  Address: 0x00001000 (out of bounds)
  Valid range: 0x00000000 - 0x00000FFF
  
Suggestion: Check array bounds and pointer arithmetic
</code></pre>
<h3 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h3>
<p>Some errors allow for recovery:</p>
<pre><code class="language-bash"># Continue execution after recoverable errors
dotvm run program.dotvm --continue-on-error
</code></pre>
<p><strong>Recoverable errors:</strong></p>
<ul>
<li>Non-fatal arithmetic errors</li>
<li>Recoverable I/O errors</li>
<li>Database connection issues</li>
</ul>
<h2 id="advanced-execution-features"><a class="header" href="#advanced-execution-features">Advanced Execution Features</a></h2>
<h3 id="instruction-limits"><a class="header" href="#instruction-limits">Instruction Limits</a></h3>
<p>Prevent infinite loops with instruction limits:</p>
<pre><code class="language-bash"># Limit to 100,000 instructions
dotvm run program.dotvm --max-instructions 100000
</code></pre>
<p><strong>Timeout behavior:</strong></p>
<pre><code>Error: Instruction limit exceeded
Instructions executed: 100,000
Execution time: 1.2s

Suggestion: Increase limit or optimize algorithm
</code></pre>
<h3 id="custom-stack-size"><a class="header" href="#custom-stack-size">Custom Stack Size</a></h3>
<p>Configure stack size for memory-intensive programs:</p>
<pre><code class="language-bash"># Set custom stack size (implementation-dependent)
DOTVM_STACK_SIZE=2MB dotvm run program.dotvm
</code></pre>
<h3 id="database-integration-2"><a class="header" href="#database-integration-2">Database Integration</a></h3>
<p>Execute programs with database operations:</p>
<pre><code class="language-bash"># Ensure database is available
dotdb create-collection users
dotdb put users '{"name": "Alice", "age": 30}'

# Run program that uses database
dotvm run database_program.dotvm --verbose
</code></pre>
<p><strong>Database operation output:</strong></p>
<pre><code>[DB] GET users.alice -&gt; {"name": "Alice", "age": 30}
[DB] PUT users.bob &lt;- {"name": "Bob", "age": 25}
[DB] COUNT users -&gt; 2
</code></pre>
<h2 id="profiling-and-optimization"><a class="header" href="#profiling-and-optimization">Profiling and Optimization</a></h2>
<h3 id="performance-profiling"><a class="header" href="#performance-profiling">Performance Profiling</a></h3>
<p>Profile program execution for optimization:</p>
<pre><code class="language-bash"># Run with profiling enabled
dotvm run program.dotvm --profile
</code></pre>
<p><strong>Profiling output:</strong></p>
<pre><code>Profiling Results:
Function                 | Calls | Total Time | Avg Time | % Total
-------------------------|-------|------------|----------|--------
main                     |     1 |    15.2ms  |  15.2ms  |  100.0%
calculate_fibonacci      |   177 |    12.8ms  |   0.07ms |   84.2%
print_result            |     1 |     2.1ms  |   2.1ms  |   13.8%
add_numbers             |    88 |     0.3ms  |   0.003ms|    2.0%

Hotspots:
1. calculate_fibonacci (84.2% of execution time)
2. print_result (13.8% of execution time)

Optimization suggestions:
- Consider memoization for calculate_fibonacci
- Use iterative approach instead of recursion
</code></pre>
<h3 id="instruction-analysis"><a class="header" href="#instruction-analysis">Instruction Analysis</a></h3>
<p>Analyze instruction usage patterns:</p>
<pre><code class="language-bash">dotvm run program.dotvm --analyze-instructions
</code></pre>
<p><strong>Instruction analysis:</strong></p>
<pre><code>Instruction Usage:
PUSH:           45.2% (1,234 executions)
ADD:            12.3% (336 executions)
CALL:           8.7% (238 executions)
RET:            8.7% (238 executions)
JZ:             6.1% (167 executions)
...

Performance impact:
- Arithmetic operations: 67.8% of execution time
- Control flow: 18.9% of execution time
- Memory operations: 8.2% of execution time
- Database operations: 5.1% of execution time
</code></pre>
<h2 id="batch-execution"><a class="header" href="#batch-execution">Batch Execution</a></h2>
<h3 id="running-multiple-programs"><a class="header" href="#running-multiple-programs">Running Multiple Programs</a></h3>
<p>Execute multiple bytecode files:</p>
<pre><code class="language-bash"># Sequential execution
for file in *.dotvm; do
    echo "Running $file..."
    dotvm run "$file"
done

# Parallel execution (if supported)
dotvm run-batch *.dotvm --parallel
</code></pre>
<h3 id="automated-testing"><a class="header" href="#automated-testing">Automated Testing</a></h3>
<p>Create test suites for bytecode programs:</p>
<pre><code class="language-bash">#!/bin/bash
# test_suite.sh

test_cases=(
    "test_arithmetic.dotvm"
    "test_control_flow.dotvm"
    "test_database.dotvm"
    "test_crypto.dotvm"
)

for test in "${test_cases[@]}"; do
    echo "Running test: $test"
    if dotvm run "$test" --quiet; then
        echo "✓ PASS: $test"
    else
        echo "✗ FAIL: $test"
        exit 1
    fi
done

echo "All tests passed!"
</code></pre>
<h2 id="integration-examples-1"><a class="header" href="#integration-examples-1">Integration Examples</a></h2>
<h3 id="web-service-backend"><a class="header" href="#web-service-backend">Web Service Backend</a></h3>
<pre><pre class="playground"><code class="language-rust">// web_service.rs
fn main() {
    println!("Starting web service...");
    
    // Initialize database
    setup_database();
    
    // Process requests
    handle_request("GET", "/users");
    handle_request("POST", "/users");
    
    println!("Service ready!");
}

fn setup_database() {
    println!("Setting up database...");
    // Database operations will use DotDB opcodes
}

fn handle_request(method: &amp;str, path: &amp;str) {
    println!("Handling {} {}", method, path);
    // Request processing logic
}</code></pre></pre>
<p><strong>Execute the service:</strong></p>
<pre><code class="language-bash">dotvm transpile -i web_service.rs -o web_service.dotvm
dotvm run web_service.dotvm --verbose
</code></pre>
<h3 id="data-processing-pipeline"><a class="header" href="#data-processing-pipeline">Data Processing Pipeline</a></h3>
<pre><pre class="playground"><code class="language-rust">// data_pipeline.rs
fn main() {
    let data = load_data();
    let processed = process_data(data);
    save_results(processed);
}

fn load_data() -&gt; Vec&lt;i32&gt; {
    println!("Loading data...");
    vec![1, 2, 3, 4, 5]
}

fn process_data(data: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    println!("Processing data...");
    data.iter().map(|x| x * 2).collect()
}

fn save_results(data: Vec&lt;i32&gt;) {
    println!("Saving results: {:?}", data);
}</code></pre></pre>
<p><strong>Execute with monitoring:</strong></p>
<pre><code class="language-bash">dotvm run data_pipeline.dotvm --verbose --profile
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="common-execution-issues"><a class="header" href="#common-execution-issues">Common Execution Issues</a></h3>
<p><strong>Bytecode not found:</strong></p>
<pre><code class="language-bash">Error: No such file or directory: program.dotvm
</code></pre>
<p><strong>Solution:</strong> Check file path and ensure bytecode file exists.</p>
<p><strong>Architecture mismatch:</strong></p>
<pre><code class="language-bash">Error: Architecture mismatch
Expected: Arch64, Found: Arch256
</code></pre>
<p><strong>Solution:</strong> Use correct bytecode for runtime architecture.</p>
<p><strong>Insufficient memory:</strong></p>
<pre><code class="language-bash">Error: Out of memory
Requested: 100MB, Available: 50MB
</code></pre>
<p><strong>Solution:</strong> Increase available memory or optimize program.</p>
<h3 id="debugging-techniques"><a class="header" href="#debugging-techniques">Debugging Techniques</a></h3>
<ol>
<li><strong>Use debug mode</strong> to trace execution</li>
<li><strong>Enable step mode</strong> for interactive debugging</li>
<li><strong>Check verbose output</strong> for detailed information</li>
<li><strong>Validate bytecode</strong> before execution</li>
<li><strong>Monitor resource usage</strong> during execution</li>
</ol>
<h3 id="performance-issues-1"><a class="header" href="#performance-issues-1">Performance Issues</a></h3>
<ol>
<li><strong>Profile execution</strong> to identify bottlenecks</li>
<li><strong>Analyze instruction patterns</strong> for optimization opportunities</li>
<li><strong>Monitor memory usage</strong> for memory leaks</li>
<li><strong>Check database operations</strong> for efficiency</li>
<li><strong>Compare different optimization levels</strong></li>
</ol>
<p>For more information about advanced features, see the <a href="dotvm/usage/advanced-features.html">Advanced Features Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-api"><a class="header" href="#runtime-api">Runtime API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-api"><a class="header" href="#compiler-api">Compiler API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dotdb-overview"><a class="header" href="#dotdb-overview">DotDB Overview</a></h1>
<p>DotDB (Dotlanth Database) is a high-performance document database designed to work seamlessly with DotVM. It provides efficient state management, document storage, and query capabilities optimized for blockchain and high-performance applications.</p>
<h2 id="what-is-dotdb"><a class="header" href="#what-is-dotdb">What is DotDB?</a></h2>
<p>DotDB is a document-oriented database that provides:</p>
<ul>
<li><strong>Document-based storage</strong>: JSON document collections with efficient indexing</li>
<li><strong>Custom storage engine</strong>: Optimized for high-performance operations</li>
<li><strong>Advanced state management</strong>: MVCC (Multi-Version Concurrency Control)</li>
<li><strong>Efficient indexing system</strong>: B+ trees, hash indices, and composite indices</li>
<li><strong>Memory management</strong>: Advanced allocators and caching systems</li>
<li><strong>Query optimization</strong>: Cost-based query planner and optimizer</li>
<li><strong>DotVM integration</strong>: Native integration with the virtual machine</li>
</ul>
<h2 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h2>
<h3 id="document-storage-model"><a class="header" href="#document-storage-model">Document Storage Model</a></h3>
<p>DotDB organizes data into collections of JSON documents:</p>
<pre><code class="language-json">{
  "collection": "users",
  "documents": [
    {
      "id": "user_123",
      "name": "Alice Johnson",
      "email": "alice@example.com",
      "age": 30,
      "preferences": {
        "theme": "dark",
        "notifications": true
      },
      "tags": ["developer", "admin"]
    }
  ]
}
</code></pre>
<h3 id="storage-engine-architecture"><a class="header" href="#storage-engine-architecture">Storage Engine Architecture</a></h3>
<pre><code>+-------------------------------------------------------------+
|                    DotDB Core                               |
+-------------------------------------------------------------+
|  +-------------+  +-------------+  +-------------------+  |
|  |  Document   |  |   Index     |  |   Query Engine    |  |
|  | Collections |  |  Manager    |  |                   |  |
|  +-------------+  +-------------+  +-------------------+  |
+-------------------------------------------------------------+
|  +-------------+  +-------------+  +-------------------+  |
|  |   Storage   |  |   Memory    |  |   Transaction     |  |
|  |   Engine    |  |  Manager    |  |     Manager       |  |
|  +-------------+  +-------------+  +-------------------+  |
+-------------------------------------------------------------+
|                    File System Layer                       |
+-------------------------------------------------------------+
</code></pre>
<h3 id="advanced-indexing"><a class="header" href="#advanced-indexing">Advanced Indexing</a></h3>
<p>DotDB supports multiple index types for optimal query performance:</p>
<ul>
<li><strong>B+ Tree Indices</strong>: Range queries and sorted access</li>
<li><strong>Hash Indices</strong>: Fast exact-match lookups</li>
<li><strong>Composite Indices</strong>: Multi-field indexing</li>
<li><strong>Full-text Indices</strong>: Text search capabilities (planned)</li>
</ul>
<h3 id="mvcc-multi-version-concurrency-control"><a class="header" href="#mvcc-multi-version-concurrency-control">MVCC (Multi-Version Concurrency Control)</a></h3>
<p>DotDB implements MVCC for concurrent access:</p>
<ul>
<li><strong>Snapshot Isolation</strong>: Consistent read views</li>
<li><strong>Non-blocking Reads</strong>: Readers don’t block writers</li>
<li><strong>Optimistic Concurrency</strong>: Minimal locking overhead</li>
<li><strong>Version Management</strong>: Automatic cleanup of old versions</li>
</ul>
<h2 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h2>
<h3 id="document-collections"><a class="header" href="#document-collections">Document Collections</a></h3>
<p>Collections are containers for related documents:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Collection operations
create_collection("users")
drop_collection("users")
list_collections()
collection_stats("users")
<span class="boring">}</span></code></pre></pre>
<h3 id="document-operations-1"><a class="header" href="#document-operations-1">Document Operations</a></h3>
<p>CRUD operations on individual documents:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Document CRUD
put_document("users", "user_123", document)
get_document("users", "user_123")
update_document("users", "user_123", new_document)
delete_document("users", "user_123")
<span class="boring">}</span></code></pre></pre>
<h3 id="query-engine"><a class="header" href="#query-engine">Query Engine</a></h3>
<p>Advanced query capabilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Query operations
find_documents("users", {"age": {"$gt": 25}})
count_documents("users", {"role": "admin"})
aggregate_documents("users", pipeline)
<span class="boring">}</span></code></pre></pre>
<h2 id="storage-engine-details"><a class="header" href="#storage-engine-details">Storage Engine Details</a></h2>
<h3 id="file-layout"><a class="header" href="#file-layout">File Layout</a></h3>
<p>DotDB uses a sophisticated file layout for optimal performance:</p>
<pre><code>database/
├── collections/
│   ├── users/
│   │   ├── data/
│   │   │   ├── segment_001.db
│   │   │   ├── segment_002.db
│   │   │   └── ...
│   │   ├── indices/
│   │   │   ├── primary.idx
│   │   │   ├── email.idx
│   │   │   └── ...
│   │   └── metadata.json
│   └── ...
├── wal/
│   ├── wal_001.log
│   └── ...
└── system/
    ├── config.json
    └── stats.json
</code></pre>
<h3 id="write-ahead-logging-wal"><a class="header" href="#write-ahead-logging-wal">Write-Ahead Logging (WAL)</a></h3>
<p>DotDB uses WAL for durability and crash recovery:</p>
<ul>
<li><strong>Atomic Writes</strong>: All changes are logged before application</li>
<li><strong>Crash Recovery</strong>: Automatic recovery from WAL on startup</li>
<li><strong>Checkpointing</strong>: Periodic WAL compaction</li>
<li><strong>Replication</strong>: WAL-based replication support (planned)</li>
</ul>
<h3 id="memory-management-2"><a class="header" href="#memory-management-2">Memory Management</a></h3>
<p>Advanced memory management for optimal performance:</p>
<ul>
<li><strong>Buffer Pool</strong>: Intelligent page caching</li>
<li><strong>Memory Allocators</strong>: Custom allocators for different data types</li>
<li><strong>Compression</strong>: Optional data compression</li>
<li><strong>Memory Mapping</strong>: Efficient file access</li>
</ul>
<h2 id="performance-characteristics-3"><a class="header" href="#performance-characteristics-3">Performance Characteristics</a></h2>
<h3 id="throughput"><a class="header" href="#throughput">Throughput</a></h3>
<p>DotDB is optimized for high throughput:</p>
<ul>
<li><strong>Batch Operations</strong>: Efficient bulk operations</li>
<li><strong>Parallel Processing</strong>: Multi-threaded query execution</li>
<li><strong>Index Optimization</strong>: Smart index selection</li>
<li><strong>Cache Efficiency</strong>: Intelligent caching strategies</li>
</ul>
<h3 id="latency"><a class="header" href="#latency">Latency</a></h3>
<p>Low-latency operations:</p>
<ul>
<li><strong>In-Memory Indices</strong>: Fast index lookups</li>
<li><strong>Optimized Data Structures</strong>: Efficient internal representations</li>
<li><strong>Minimal Serialization</strong>: Reduced overhead</li>
<li><strong>Direct Memory Access</strong>: Zero-copy operations where possible</li>
</ul>
<h3 id="scalability-1"><a class="header" href="#scalability-1">Scalability</a></h3>
<p>Designed for scalability:</p>
<ul>
<li><strong>Horizontal Scaling</strong>: Sharding support (planned)</li>
<li><strong>Vertical Scaling</strong>: Efficient resource utilization</li>
<li><strong>Storage Efficiency</strong>: Compact data representation</li>
<li><strong>Index Scaling</strong>: Scalable index structures</li>
</ul>
<h2 id="integration-with-dotvm-1"><a class="header" href="#integration-with-dotvm-1">Integration with DotVM</a></h2>
<p>DotDB is tightly integrated with DotVM for optimal performance:</p>
<h3 id="native-opcodes"><a class="header" href="#native-opcodes">Native Opcodes</a></h3>
<p>DotVM provides native database opcodes:</p>
<pre><code class="language-assembly">; Store user data
PUSH "users"
PUSH "user_123"
PUSH {"name": "Alice", "age": 30}
DB_PUT

; Retrieve user data
PUSH "users"
PUSH "user_123"
DB_GET
</code></pre>
<h3 id="state-management"><a class="header" href="#state-management">State Management</a></h3>
<p>Seamless state persistence:</p>
<ul>
<li><strong>Automatic Persistence</strong>: VM state automatically persisted</li>
<li><strong>Transaction Boundaries</strong>: VM transactions map to DB transactions</li>
<li><strong>Rollback Support</strong>: Automatic rollback on VM errors</li>
<li><strong>Snapshot Consistency</strong>: Consistent state views</li>
</ul>
<h3 id="performance-optimization-2"><a class="header" href="#performance-optimization-2">Performance Optimization</a></h3>
<p>Optimized for VM workloads:</p>
<ul>
<li><strong>Predictable Latency</strong>: Consistent performance for VM operations</li>
<li><strong>Memory Sharing</strong>: Shared memory between VM and DB</li>
<li><strong>Batch Processing</strong>: Efficient bulk operations from VM</li>
<li><strong>Connection Pooling</strong>: Optimized connection management</li>
</ul>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="blockchain-applications"><a class="header" href="#blockchain-applications">Blockchain Applications</a></h3>
<p>DotDB is ideal for blockchain state management:</p>
<ul>
<li><strong>Account State</strong>: User accounts and balances</li>
<li><strong>Smart Contract State</strong>: Contract storage and execution state</li>
<li><strong>Transaction History</strong>: Immutable transaction logs</li>
<li><strong>Block Data</strong>: Block headers and transaction data</li>
</ul>
<h3 id="web-applications"><a class="header" href="#web-applications">Web Applications</a></h3>
<p>Traditional web application backends:</p>
<ul>
<li><strong>User Management</strong>: User profiles and authentication</li>
<li><strong>Content Management</strong>: Articles, posts, and media</li>
<li><strong>Session Storage</strong>: User sessions and temporary data</li>
<li><strong>Analytics</strong>: Event tracking and metrics</li>
</ul>
<h3 id="iot-and-edge-computing"><a class="header" href="#iot-and-edge-computing">IoT and Edge Computing</a></h3>
<p>Optimized for resource-constrained environments:</p>
<ul>
<li><strong>Sensor Data</strong>: Time-series sensor readings</li>
<li><strong>Device State</strong>: Device configuration and status</li>
<li><strong>Event Logs</strong>: System and application events</li>
<li><strong>Local Caching</strong>: Edge data caching</li>
</ul>
<h3 id="scientific-computing"><a class="header" href="#scientific-computing">Scientific Computing</a></h3>
<p>High-performance data processing:</p>
<ul>
<li><strong>Research Data</strong>: Experimental data and results</li>
<li><strong>Simulation State</strong>: Computational simulation checkpoints</li>
<li><strong>Metadata</strong>: Dataset descriptions and annotations</li>
<li><strong>Collaboration</strong>: Shared research data</li>
</ul>
<h2 id="cli-interface"><a class="header" href="#cli-interface">CLI Interface</a></h2>
<p>DotDB provides a comprehensive CLI for database operations:</p>
<h3 id="collection-management-1"><a class="header" href="#collection-management-1">Collection Management</a></h3>
<pre><code class="language-bash"># Create and manage collections
dotdb create-collection users
dotdb delete-collection users
dotdb collections
</code></pre>
<h3 id="document-operations-2"><a class="header" href="#document-operations-2">Document Operations</a></h3>
<pre><code class="language-bash"># CRUD operations
dotdb put users '{"name": "Alice", "age": 30}'
dotdb get users user_123
dotdb update users user_123 '{"name": "Alice", "age": 31}'
dotdb delete users user_123
</code></pre>
<h3 id="query-operations"><a class="header" href="#query-operations">Query Operations</a></h3>
<pre><code class="language-bash"># Search and analytics
dotdb find users age 30
dotdb count users
dotdb list users
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>DotDB supports extensive configuration options:</p>
<h3 id="storage-configuration"><a class="header" href="#storage-configuration">Storage Configuration</a></h3>
<pre><code class="language-json">{
  "storage": {
    "data_directory": "/var/lib/dotdb",
    "wal_directory": "/var/lib/dotdb/wal",
    "segment_size": "64MB",
    "compression": "lz4",
    "sync_mode": "normal"
  }
}
</code></pre>
<h3 id="memory-configuration"><a class="header" href="#memory-configuration">Memory Configuration</a></h3>
<pre><code class="language-json">{
  "memory": {
    "buffer_pool_size": "1GB",
    "cache_size": "256MB",
    "max_connections": 1000,
    "worker_threads": 8
  }
}
</code></pre>
<h3 id="index-configuration"><a class="header" href="#index-configuration">Index Configuration</a></h3>
<pre><code class="language-json">{
  "indexing": {
    "auto_index": true,
    "index_cache_size": "128MB",
    "btree_page_size": "4KB",
    "hash_bucket_count": 1024
  }
}
</code></pre>
<h2 id="security-features-2"><a class="header" href="#security-features-2">Security Features</a></h2>
<p>DotDB implements multiple security layers:</p>
<h3 id="access-control"><a class="header" href="#access-control">Access Control</a></h3>
<ul>
<li><strong>Authentication</strong>: User authentication and authorization</li>
<li><strong>Role-Based Access</strong>: Fine-grained permission system</li>
<li><strong>Collection-Level Security</strong>: Per-collection access controls</li>
<li><strong>API Security</strong>: Secure API endpoints and protocols</li>
</ul>
<h3 id="data-protection"><a class="header" href="#data-protection">Data Protection</a></h3>
<ul>
<li><strong>Encryption at Rest</strong>: Optional data encryption</li>
<li><strong>Encryption in Transit</strong>: TLS/SSL support</li>
<li><strong>Data Integrity</strong>: Checksums and validation</li>
<li><strong>Backup Security</strong>: Secure backup and restore</li>
</ul>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<ol>
<li><strong>Installation</strong>: Follow the <a href="dotdb/../getting-started/installation.html">installation guide</a></li>
<li><strong>CLI Tutorial</strong>: Learn the <a href="dotdb/../cli/dotdb.html">DotDB CLI</a></li>
<li><strong>Basic Operations</strong>: Try <a href="dotdb/usage/basic-operations.html">basic operations</a></li>
<li><strong>Integration</strong>: Explore <a href="dotdb/../dotvm/overview.html">DotVM integration</a></li>
</ol>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><strong>Architecture Details</strong>: Learn about the <a href="dotdb/architecture/storage-engine.html">storage engine</a></li>
<li><strong>Document Management</strong>: Read about <a href="dotdb/usage/document-management.html">document operations</a></li>
<li><strong>Advanced Features</strong>: Explore <a href="dotdb/usage/advanced-features.html">advanced capabilities</a></li>
<li><strong>API Reference</strong>: Check the <a href="dotdb/api/core.html">Core API documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-management-1"><a class="header" href="#state-management-1">State Management</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="document-collections-1"><a class="header" href="#document-collections-1">Document Collections</a></h1>
<p>Document collections are the primary organizational unit in DotDB. They group related documents together and provide the foundation for indexing, querying, and data management operations.</p>
<h2 id="collection-concepts"><a class="header" href="#collection-concepts">Collection Concepts</a></h2>
<h3 id="what-is-a-collection"><a class="header" href="#what-is-a-collection">What is a Collection?</a></h3>
<p>A collection in DotDB is similar to a table in relational databases or a collection in MongoDB. It contains a set of related JSON documents that share common characteristics or serve similar purposes.</p>
<p><strong>Key Properties:</strong></p>
<ul>
<li><strong>Schema-flexible</strong>: Documents in a collection can have different structures</li>
<li><strong>Indexed</strong>: Collections support multiple index types for efficient queries</li>
<li><strong>Isolated</strong>: Collections provide logical separation of data</li>
<li><strong>Scalable</strong>: Collections can grow to handle large datasets</li>
</ul>
<h3 id="collection-naming"><a class="header" href="#collection-naming">Collection Naming</a></h3>
<p>Collection names must follow specific rules:</p>
<p><strong>Valid Names:</strong></p>
<ul>
<li>Must start with a letter or underscore</li>
<li>Can contain letters, numbers, underscores, and hyphens</li>
<li>Case-sensitive</li>
<li>Maximum length: 64 characters</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code>users           ✓ Valid
user_profiles   ✓ Valid
user-data       ✓ Valid
_system         ✓ Valid
123users        ✗ Invalid (starts with number)
user@data       ✗ Invalid (contains @)
</code></pre>
<h2 id="collection-structure"><a class="header" href="#collection-structure">Collection Structure</a></h2>
<h3 id="physical-layout"><a class="header" href="#physical-layout">Physical Layout</a></h3>
<p>Each collection has its own directory structure:</p>
<pre><code>collections/
└── users/
    ├── metadata.json      # Collection metadata
    ├── data/             # Document storage
    │   ├── segment_001.db
    │   ├── segment_002.db
    │   └── ...
    ├── indices/          # Index files
    │   ├── primary.idx   # Primary key index
    │   ├── email.idx     # Secondary indices
    │   └── ...
    └── wal/              # Write-ahead log
        ├── wal_001.log
        └── ...
</code></pre>
<h3 id="metadata-structure"><a class="header" href="#metadata-structure">Metadata Structure</a></h3>
<p>Collection metadata is stored in <code>metadata.json</code>:</p>
<pre><code class="language-json">{
  "name": "users",
  "created_at": "2025-01-01T00:00:00Z",
  "updated_at": "2025-01-01T12:00:00Z",
  "document_count": 1500,
  "total_size": 1048576,
  "indices": [
    {
      "name": "primary",
      "type": "btree",
      "fields": ["_id"],
      "unique": true
    },
    {
      "name": "email_idx",
      "type": "hash",
      "fields": ["email"],
      "unique": true
    }
  ],
  "settings": {
    "auto_index": true,
    "compression": "lz4",
    "segment_size": 67108864
  }
}
</code></pre>
<h2 id="document-storage"><a class="header" href="#document-storage">Document Storage</a></h2>
<h3 id="document-format"><a class="header" href="#document-format">Document Format</a></h3>
<p>Documents are stored as JSON with additional metadata:</p>
<pre><code class="language-json">{
  "_id": "user_123",
  "_version": 1,
  "_created_at": "2025-01-01T00:00:00Z",
  "_updated_at": "2025-01-01T00:00:00Z",
  "name": "Alice Johnson",
  "email": "alice@example.com",
  "age": 30,
  "preferences": {
    "theme": "dark",
    "notifications": true
  }
}
</code></pre>
<h3 id="system-fields"><a class="header" href="#system-fields">System Fields</a></h3>
<p>DotDB automatically adds system fields to each document:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_id</code></td><td>String</td><td>Unique document identifier</td></tr>
<tr><td><code>_version</code></td><td>Integer</td><td>Document version number</td></tr>
<tr><td><code>_created_at</code></td><td>Timestamp</td><td>Document creation time</td></tr>
<tr><td><code>_updated_at</code></td><td>Timestamp</td><td>Last modification time</td></tr>
<tr><td><code>_size</code></td><td>Integer</td><td>Document size in bytes</td></tr>
</tbody></table>
</div>
<h3 id="document-identifiers"><a class="header" href="#document-identifiers">Document Identifiers</a></h3>
<p>Document IDs can be:</p>
<ul>
<li><strong>Auto-generated</strong>: UUIDs generated by DotDB</li>
<li><strong>User-provided</strong>: Custom strings provided by the application</li>
<li><strong>Composite</strong>: Generated from multiple fields</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Auto-generated ID
put_document("users", None, document) // Returns generated ID

// User-provided ID
put_document("users", Some("user_123"), document)

// Composite ID (application logic)
let id = format!("{}_{}", user.email, user.created_at);
put_document("users", Some(&amp;id), document)
<span class="boring">}</span></code></pre></pre>
<h2 id="collection-operations"><a class="header" href="#collection-operations">Collection Operations</a></h2>
<h3 id="creating-collections"><a class="header" href="#creating-collections">Creating Collections</a></h3>
<p>Collections can be created explicitly or implicitly:</p>
<p><strong>Explicit Creation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create collection with default settings
create_collection("users")?;

// Create collection with custom settings
let settings = CollectionSettings {
    auto_index: true,
    compression: CompressionType::Lz4,
    segment_size: 64 * 1024 * 1024, // 64MB
};
create_collection_with_settings("users", settings)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Implicit Creation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Collection created automatically on first document insert
put_document("new_collection", "doc_1", document)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="listing-collections"><a class="header" href="#listing-collections">Listing Collections</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get all collection names
let collections = list_collections()?;

// Get collection metadata
let metadata = get_collection_metadata("users")?;

// Get collection statistics
let stats = get_collection_stats("users")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="dropping-collections"><a class="header" href="#dropping-collections">Dropping Collections</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Drop collection and all its data
drop_collection("users")?;

// Drop collection with confirmation
drop_collection_confirmed("users", "users")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="indexing"><a class="header" href="#indexing">Indexing</a></h2>
<h3 id="index-types"><a class="header" href="#index-types">Index Types</a></h3>
<p>DotDB supports multiple index types:</p>
<h4 id="primary-index-b-tree"><a class="header" href="#primary-index-b-tree">Primary Index (B+ Tree)</a></h4>
<ul>
<li><strong>Purpose</strong>: Unique document identification</li>
<li><strong>Fields</strong>: <code>_id</code> field</li>
<li><strong>Properties</strong>: Always unique, automatically created</li>
</ul>
<h4 id="secondary-indices"><a class="header" href="#secondary-indices">Secondary Indices</a></h4>
<p><strong>Hash Index:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_index("users", "email_idx", IndexType::Hash, &amp;["email"], true)?;
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Use Case</strong>: Exact-match queries</li>
<li><strong>Performance</strong>: O(1) lookup time</li>
<li><strong>Limitations</strong>: No range queries</li>
</ul>
<p><strong>B+ Tree Index:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_index("users", "age_idx", IndexType::BTree, &amp;["age"], false)?;
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Use Case</strong>: Range queries, sorting</li>
<li><strong>Performance</strong>: O(log n) lookup time</li>
<li><strong>Features</strong>: Supports range operations</li>
</ul>
<p><strong>Composite Index:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_index("users", "name_age_idx", IndexType::BTree, &amp;["name", "age"], false)?;
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Use Case</strong>: Multi-field queries</li>
<li><strong>Performance</strong>: Efficient for prefix queries</li>
<li><strong>Order</strong>: Field order matters</li>
</ul>
<h3 id="index-management"><a class="header" href="#index-management">Index Management</a></h3>
<p><strong>Creating Indices:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple index
create_index("users", "email_idx", IndexType::Hash, &amp;["email"], true)?;

// Composite index
create_index("users", "location_idx", IndexType::BTree, &amp;["city", "state"], false)?;

// Partial index (planned feature)
create_partial_index("users", "active_users", &amp;["status"], "status = 'active'")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Managing Indices:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// List indices for a collection
let indices = list_indices("users")?;

// Drop an index
drop_index("users", "email_idx")?;

// Rebuild an index
rebuild_index("users", "email_idx")?;

// Get index statistics
let stats = get_index_stats("users", "email_idx")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="collection-settings"><a class="header" href="#collection-settings">Collection Settings</a></h2>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<p>Collections support various configuration options:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CollectionSettings {
    pub auto_index: bool,           // Automatically create indices
    pub compression: CompressionType, // Data compression
    pub segment_size: usize,        // Segment file size
    pub cache_size: usize,          // Collection cache size
    pub sync_mode: SyncMode,        // Durability settings
    pub max_document_size: usize,   // Maximum document size
}
<span class="boring">}</span></code></pre></pre>
<h3 id="compression"><a class="header" href="#compression">Compression</a></h3>
<p>DotDB supports multiple compression algorithms:</p>
<ul>
<li><strong>None</strong>: No compression (fastest)</li>
<li><strong>LZ4</strong>: Fast compression with good ratio</li>
<li><strong>Zstd</strong>: Better compression ratio, slower</li>
<li><strong>Snappy</strong>: Google’s compression algorithm</li>
</ul>
<p><strong>Performance Comparison:</strong></p>
<pre><code>Algorithm | Compression Ratio | Speed | CPU Usage
----------|------------------|-------|----------
None      | 1.0x            | ★★★★★ | ★☆☆☆☆
LZ4       | 2.5x            | ★★★★☆ | ★★☆☆☆
Snappy    | 2.2x            | ★★★☆☆ | ★★☆☆☆
Zstd      | 3.5x            | ★★☆☆☆ | ★★★☆☆
</code></pre>
<h3 id="sync-modes"><a class="header" href="#sync-modes">Sync Modes</a></h3>
<p>Control durability vs. performance trade-offs:</p>
<ul>
<li><strong>None</strong>: No explicit syncing (fastest, least durable)</li>
<li><strong>Normal</strong>: Sync on transaction commit</li>
<li><strong>Full</strong>: Sync after every write (slowest, most durable)</li>
</ul>
<h2 id="collection-statistics"><a class="header" href="#collection-statistics">Collection Statistics</a></h2>
<h3 id="monitoring-collections"><a class="header" href="#monitoring-collections">Monitoring Collections</a></h3>
<p>DotDB provides comprehensive collection statistics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CollectionStats {
    pub document_count: u64,
    pub total_size: u64,
    pub average_document_size: f64,
    pub index_count: usize,
    pub index_size: u64,
    pub segment_count: usize,
    pub compression_ratio: f64,
    pub read_operations: u64,
    pub write_operations: u64,
    pub cache_hit_ratio: f64,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-metrics"><a class="header" href="#performance-metrics">Performance Metrics</a></h3>
<p><strong>Query Performance:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get query execution statistics
let query_stats = get_query_stats("users")?;
println!("Average query time: {}ms", query_stats.avg_query_time);
println!("Index usage: {}%", query_stats.index_usage_ratio);
<span class="boring">}</span></code></pre></pre>
<p><strong>Storage Metrics:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get storage utilization
let storage_stats = get_storage_stats("users")?;
println!("Storage efficiency: {}%", storage_stats.efficiency);
println!("Fragmentation: {}%", storage_stats.fragmentation);
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="collection-design"><a class="header" href="#collection-design">Collection Design</a></h3>
<ol>
<li><strong>Logical Grouping</strong>: Group related documents together</li>
<li><strong>Size Considerations</strong>: Keep collections manageable (&lt; 10M documents)</li>
<li><strong>Index Strategy</strong>: Create indices for common query patterns</li>
<li><strong>Naming Convention</strong>: Use consistent, descriptive names</li>
</ol>
<h3 id="performance-optimization-3"><a class="header" href="#performance-optimization-3">Performance Optimization</a></h3>
<ol>
<li><strong>Index Selection</strong>: Choose appropriate index types</li>
<li><strong>Document Size</strong>: Keep documents reasonably sized (&lt; 1MB)</li>
<li><strong>Batch Operations</strong>: Use bulk operations for better performance</li>
<li><strong>Compression</strong>: Enable compression for large collections</li>
</ol>
<h3 id="schema-design"><a class="header" href="#schema-design">Schema Design</a></h3>
<ol>
<li><strong>Consistent Structure</strong>: Maintain consistent document structure</li>
<li><strong>Field Naming</strong>: Use consistent field naming conventions</li>
<li><strong>Nested Objects</strong>: Limit nesting depth for better performance</li>
<li><strong>Array Fields</strong>: Consider index implications for array fields</li>
</ol>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="e-commerce-application"><a class="header" href="#e-commerce-application">E-commerce Application</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Product catalog
create_collection("products")?;
create_index("products", "category_idx", IndexType::BTree, &amp;["category"], false)?;
create_index("products", "price_idx", IndexType::BTree, &amp;["price"], false)?;
create_index("products", "sku_idx", IndexType::Hash, &amp;["sku"], true)?;

// User orders
create_collection("orders")?;
create_index("orders", "user_idx", IndexType::Hash, &amp;["user_id"], false)?;
create_index("orders", "date_idx", IndexType::BTree, &amp;["order_date"], false)?;
create_index("orders", "status_idx", IndexType::Hash, &amp;["status"], false)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="content-management-system"><a class="header" href="#content-management-system">Content Management System</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Articles
create_collection("articles")?;
create_index("articles", "author_idx", IndexType::Hash, &amp;["author_id"], false)?;
create_index("articles", "published_idx", IndexType::BTree, &amp;["published_at"], false)?;
create_index("articles", "category_idx", IndexType::BTree, &amp;["category"], false)?;

// Comments
create_collection("comments")?;
create_index("comments", "article_idx", IndexType::Hash, &amp;["article_id"], false)?;
create_index("comments", "user_idx", IndexType::Hash, &amp;["user_id"], false)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="iot-data-collection"><a class="header" href="#iot-data-collection">IoT Data Collection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sensor readings
create_collection("sensor_data")?;
create_index("sensor_data", "device_time_idx", IndexType::BTree, &amp;["device_id", "timestamp"], false)?;
create_index("sensor_data", "type_idx", IndexType::Hash, &amp;["sensor_type"], false)?;

// Device status
create_collection("devices")?;
create_index("devices", "location_idx", IndexType::BTree, &amp;["location"], false)?;
create_index("devices", "status_idx", IndexType::Hash, &amp;["status"], false)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="common-issues-2"><a class="header" href="#common-issues-2">Common Issues</a></h3>
<ol>
<li><strong>Collection Not Found</strong>: Ensure collection exists before operations</li>
<li><strong>Index Conflicts</strong>: Check for duplicate index names</li>
<li><strong>Performance Issues</strong>: Review index usage and query patterns</li>
<li><strong>Storage Growth</strong>: Monitor collection size and implement cleanup</li>
</ol>
<h3 id="diagnostic-commands"><a class="header" href="#diagnostic-commands">Diagnostic Commands</a></h3>
<pre><code class="language-bash"># Collection information
dotdb collections
dotdb count collection_name

# Index information
dotdb list-indices collection_name
dotdb index-stats collection_name index_name

# Performance analysis
dotdb analyze collection_name
dotdb query-plan collection_name "query"
</code></pre>
<p>For more information about working with documents, see <a href="dotdb/architecture/../usage/document-management.html">Document Management</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-2"><a class="header" href="#usage-2">Usage</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="document-management"><a class="header" href="#document-management">Document Management</a></h1>
<p>This guide covers comprehensive document management in DotDB, including CRUD operations, querying, indexing strategies, and performance optimization.</p>
<h2 id="document-basics"><a class="header" href="#document-basics">Document Basics</a></h2>
<h3 id="document-structure"><a class="header" href="#document-structure">Document Structure</a></h3>
<p>DotDB documents are JSON objects with automatic system fields:</p>
<pre><code class="language-json">{
  "_id": "user_123",
  "_version": 1,
  "_created_at": "2025-01-01T00:00:00Z",
  "_updated_at": "2025-01-01T00:00:00Z",
  "name": "Alice Johnson",
  "email": "alice@example.com",
  "age": 30,
  "preferences": {
    "theme": "dark",
    "notifications": true
  },
  "tags": ["developer", "admin"]
}
</code></pre>
<h3 id="system-fields-1"><a class="header" href="#system-fields-1">System Fields</a></h3>
<p>DotDB automatically manages system fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Editable</th></tr></thead><tbody>
<tr><td><code>_id</code></td><td>String</td><td>Unique document identifier</td><td>No</td></tr>
<tr><td><code>_version</code></td><td>Integer</td><td>Document version number</td><td>No</td></tr>
<tr><td><code>_created_at</code></td><td>Timestamp</td><td>Creation timestamp</td><td>No</td></tr>
<tr><td><code>_updated_at</code></td><td>Timestamp</td><td>Last modification timestamp</td><td>No</td></tr>
<tr><td><code>_size</code></td><td>Integer</td><td>Document size in bytes</td><td>No</td></tr>
</tbody></table>
</div>
<h2 id="crud-operations"><a class="header" href="#crud-operations">CRUD Operations</a></h2>
<h3 id="creating-documents"><a class="header" href="#creating-documents">Creating Documents</a></h3>
<h4 id="using-cli"><a class="header" href="#using-cli">Using CLI</a></h4>
<p><strong>Insert with auto-generated ID:</strong></p>
<pre><code class="language-bash">dotdb put users '{
  "name": "Alice Johnson",
  "email": "alice@example.com",
  "age": 30,
  "role": "developer"
}'
</code></pre>
<p><strong>Response:</strong></p>
<pre><code>Document inserted successfully
ID: user_507f1f77bcf86cd799439011
Collection: users
</code></pre>
<h4 id="batch-insert"><a class="header" href="#batch-insert">Batch Insert</a></h4>
<p>Insert multiple documents efficiently:</p>
<pre><code class="language-bash"># Create a JSON file with multiple documents
cat &gt; users_batch.json &lt;&lt; EOF
[
  {"name": "Alice", "email": "alice@example.com", "age": 30},
  {"name": "Bob", "email": "bob@example.com", "age": 25},
  {"name": "Charlie", "email": "charlie@example.com", "age": 35}
]
EOF

# Batch insert (conceptual - would need implementation)
dotdb batch-put users users_batch.json
</code></pre>
<h3 id="reading-documents"><a class="header" href="#reading-documents">Reading Documents</a></h3>
<h4 id="get-by-id"><a class="header" href="#get-by-id">Get by ID</a></h4>
<pre><code class="language-bash">dotdb get users user_507f1f77bcf86cd799439011
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "_id": "user_507f1f77bcf86cd799439011",
  "_version": 1,
  "_created_at": "2025-01-01T00:00:00Z",
  "_updated_at": "2025-01-01T00:00:00Z",
  "name": "Alice Johnson",
  "email": "alice@example.com",
  "age": 30,
  "role": "developer"
}
</code></pre>
<h4 id="list-all-documents"><a class="header" href="#list-all-documents">List All Documents</a></h4>
<pre><code class="language-bash">dotdb list users
</code></pre>
<p><strong>Response:</strong></p>
<pre><code>Documents in collection 'users':
- user_507f1f77bcf86cd799439011
- user_507f1f77bcf86cd799439012
- user_507f1f77bcf86cd799439013
Total: 3 documents
</code></pre>
<h4 id="find-documents-by-field"><a class="header" href="#find-documents-by-field">Find Documents by Field</a></h4>
<pre><code class="language-bash"># Find by exact match
dotdb find users role '"developer"'

# Find by age
dotdb find users age 30

# Find by nested field (conceptual)
dotdb find users preferences.theme '"dark"'
</code></pre>
<h3 id="updating-documents"><a class="header" href="#updating-documents">Updating Documents</a></h3>
<h4 id="full-document-update"><a class="header" href="#full-document-update">Full Document Update</a></h4>
<pre><code class="language-bash">dotdb update users user_507f1f77bcf86cd799439011 '{
  "name": "Alice Smith",
  "email": "alice.smith@example.com",
  "age": 31,
  "role": "senior_developer",
  "department": "engineering"
}'
</code></pre>
<p><strong>Response:</strong></p>
<pre><code>Document updated successfully
ID: user_507f1f77bcf86cd799439011
Version: 2
Updated fields: name, email, age, role, department
</code></pre>
<h4 id="partial-updates-conceptual"><a class="header" href="#partial-updates-conceptual">Partial Updates (Conceptual)</a></h4>
<pre><code class="language-bash"># Update specific fields only
dotdb patch users user_507f1f77bcf86cd799439011 '{
  "age": 31,
  "role": "senior_developer"
}'
</code></pre>
<h3 id="deleting-documents"><a class="header" href="#deleting-documents">Deleting Documents</a></h3>
<h4 id="delete-by-id"><a class="header" href="#delete-by-id">Delete by ID</a></h4>
<pre><code class="language-bash">dotdb delete users user_507f1f77bcf86cd799439011
</code></pre>
<p><strong>Response:</strong></p>
<pre><code>Document deleted successfully
ID: user_507f1f77bcf86cd799439011
Collection: users
</code></pre>
<h4 id="bulk-delete-conceptual"><a class="header" href="#bulk-delete-conceptual">Bulk Delete (Conceptual)</a></h4>
<pre><code class="language-bash"># Delete all documents matching criteria
dotdb delete-where users '{"role": "inactive"}'
</code></pre>
<h2 id="advanced-querying"><a class="header" href="#advanced-querying">Advanced Querying</a></h2>
<h3 id="query-operators-conceptual"><a class="header" href="#query-operators-conceptual">Query Operators (Conceptual)</a></h3>
<p>DotDB supports MongoDB-style query operators:</p>
<h4 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h4>
<pre><code class="language-bash"># Greater than
dotdb query users '{"age": {"$gt": 25}}'

# Less than or equal
dotdb query users '{"age": {"$lte": 30}}'

# In array
dotdb query users '{"role": {"$in": ["developer", "admin"]}}'

# Not equal
dotdb query users '{"status": {"$ne": "inactive"}}'
</code></pre>
<h4 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h4>
<pre><code class="language-bash"># AND condition
dotdb query users '{
  "$and": [
    {"age": {"$gt": 25}},
    {"role": "developer"}
  ]
}'

# OR condition
dotdb query users '{
  "$or": [
    {"role": "admin"},
    {"age": {"$gt": 50}}
  ]
}'
</code></pre>
<h4 id="array-operators"><a class="header" href="#array-operators">Array Operators</a></h4>
<pre><code class="language-bash"># Array contains element
dotdb query users '{"tags": {"$elemMatch": "admin"}}'

# Array size
dotdb query users '{"tags": {"$size": 2}}'

# All elements match
dotdb query users '{"tags": {"$all": ["developer", "admin"]}}'
</code></pre>
<h3 id="projection-conceptual"><a class="header" href="#projection-conceptual">Projection (Conceptual)</a></h3>
<p>Select specific fields to return:</p>
<pre><code class="language-bash"># Return only name and email
dotdb query users '{}' --fields 'name,email'

# Exclude system fields
dotdb query users '{}' --exclude '_version,_created_at,_updated_at'
</code></pre>
<h3 id="sorting-and-limiting"><a class="header" href="#sorting-and-limiting">Sorting and Limiting</a></h3>
<pre><code class="language-bash"># Sort by age ascending
dotdb query users '{}' --sort 'age:1'

# Sort by age descending
dotdb query users '{}' --sort 'age:-1'

# Limit results
dotdb query users '{}' --limit 10

# Skip and limit (pagination)
dotdb query users '{}' --skip 20 --limit 10
</code></pre>
<h2 id="indexing-for-performance"><a class="header" href="#indexing-for-performance">Indexing for Performance</a></h2>
<h3 id="creating-indices"><a class="header" href="#creating-indices">Creating Indices</a></h3>
<h4 id="single-field-index"><a class="header" href="#single-field-index">Single Field Index</a></h4>
<pre><code class="language-bash"># Create index on email field
dotdb create-index users email_idx email --unique

# Create index on age field
dotdb create-index users age_idx age
</code></pre>
<h4 id="compound-index"><a class="header" href="#compound-index">Compound Index</a></h4>
<pre><code class="language-bash"># Create compound index on multiple fields
dotdb create-index users name_age_idx name,age

# Create index with custom options
dotdb create-index users location_idx city,state --type btree
</code></pre>
<h4 id="index-types-1"><a class="header" href="#index-types-1">Index Types</a></h4>
<p><strong>Hash Index (Fast Equality):</strong></p>
<pre><code class="language-bash">dotdb create-index users email_hash_idx email --type hash --unique
</code></pre>
<ul>
<li><strong>Use case</strong>: Exact match queries</li>
<li><strong>Performance</strong>: O(1) lookup</li>
<li><strong>Limitations</strong>: No range queries</li>
</ul>
<p><strong>B-Tree Index (Range Queries):</strong></p>
<pre><code class="language-bash">dotdb create-index users age_btree_idx age --type btree
</code></pre>
<ul>
<li><strong>Use case</strong>: Range queries, sorting</li>
<li><strong>Performance</strong>: O(log n) lookup</li>
<li><strong>Features</strong>: Supports &lt;, &gt;, &lt;=, &gt;= operations</li>
</ul>
<h3 id="index-management-1"><a class="header" href="#index-management-1">Index Management</a></h3>
<h4 id="list-indices"><a class="header" href="#list-indices">List Indices</a></h4>
<pre><code class="language-bash">dotdb list-indices users
</code></pre>
<p><strong>Response:</strong></p>
<pre><code>Indices for collection 'users':
- primary (btree, unique) on [_id]
- email_idx (hash, unique) on [email]
- age_idx (btree) on [age]
- name_age_idx (btree) on [name, age]
Total: 4 indices
</code></pre>
<h4 id="index-statistics"><a class="header" href="#index-statistics">Index Statistics</a></h4>
<pre><code class="language-bash">dotdb index-stats users email_idx
</code></pre>
<p><strong>Response:</strong></p>
<pre><code>Index Statistics: users.email_idx
Type: Hash
Fields: [email]
Unique: true
Size: 2.1 MB
Entries: 10,000
Usage: 95.2% (queries using this index)
Last used: 2025-01-01T12:00:00Z
</code></pre>
<h4 id="drop-index"><a class="header" href="#drop-index">Drop Index</a></h4>
<pre><code class="language-bash">dotdb drop-index users email_idx
</code></pre>
<h3 id="query-optimization"><a class="header" href="#query-optimization">Query Optimization</a></h3>
<h4 id="explain-query-plan"><a class="header" href="#explain-query-plan">Explain Query Plan</a></h4>
<pre><code class="language-bash">dotdb explain users '{"email": "alice@example.com"}'
</code></pre>
<p><strong>Response:</strong></p>
<pre><code>Query Plan:
Collection: users
Query: {"email": "alice@example.com"}

Execution Plan:
1. Index Scan: email_idx (hash)
   - Index: users.email_idx
   - Type: Hash lookup
   - Estimated cost: 1
   - Estimated rows: 1

Performance:
- Execution time: 0.1ms
- Documents examined: 1
- Documents returned: 1
- Index hit: Yes
</code></pre>
<h4 id="query-performance-tips"><a class="header" href="#query-performance-tips">Query Performance Tips</a></h4>
<ol>
<li><strong>Create appropriate indices</strong> for common query patterns</li>
<li><strong>Use compound indices</strong> for multi-field queries</li>
<li><strong>Avoid full collection scans</strong> by ensuring queries use indices</li>
<li><strong>Monitor query performance</strong> with explain plans</li>
<li><strong>Consider index selectivity</strong> when designing indices</li>
</ol>
<h2 id="data-validation"><a class="header" href="#data-validation">Data Validation</a></h2>
<h3 id="schema-validation-conceptual"><a class="header" href="#schema-validation-conceptual">Schema Validation (Conceptual)</a></h3>
<p>Define validation rules for documents:</p>
<pre><code class="language-json">{
  "collection": "users",
  "schema": {
    "type": "object",
    "required": ["name", "email"],
    "properties": {
      "name": {
        "type": "string",
        "minLength": 1,
        "maxLength": 100
      },
      "email": {
        "type": "string",
        "format": "email"
      },
      "age": {
        "type": "integer",
        "minimum": 0,
        "maximum": 150
      }
    }
  }
}
</code></pre>
<h3 id="validation-examples"><a class="header" href="#validation-examples">Validation Examples</a></h3>
<pre><code class="language-bash"># Valid document
dotdb put users '{
  "name": "Alice",
  "email": "alice@example.com",
  "age": 30
}'  # Success

# Invalid document (missing required field)
dotdb put users '{
  "name": "Bob"
}'  # Error: Missing required field 'email'

# Invalid document (invalid email format)
dotdb put users '{
  "name": "Charlie",
  "email": "invalid-email"
}'  # Error: Invalid email format
</code></pre>
<h2 id="document-versioning"><a class="header" href="#document-versioning">Document Versioning</a></h2>
<h3 id="version-control"><a class="header" href="#version-control">Version Control</a></h3>
<p>DotDB automatically manages document versions:</p>
<pre><code class="language-bash"># Initial insert (version 1)
dotdb put users '{"name": "Alice", "age": 30}'

# Update (version 2)
dotdb update users user_123 '{"name": "Alice", "age": 31}'

# Another update (version 3)
dotdb update users user_123 '{"name": "Alice Smith", "age": 31}'
</code></pre>
<h3 id="version-history-conceptual"><a class="header" href="#version-history-conceptual">Version History (Conceptual)</a></h3>
<pre><code class="language-bash"># Get document history
dotdb history users user_123

# Get specific version
dotdb get users user_123 --version 2

# Revert to previous version
dotdb revert users user_123 --to-version 2
</code></pre>
<h2 id="aggregation-and-analytics"><a class="header" href="#aggregation-and-analytics">Aggregation and Analytics</a></h2>
<h3 id="basic-aggregation"><a class="header" href="#basic-aggregation">Basic Aggregation</a></h3>
<h4 id="count-documents"><a class="header" href="#count-documents">Count Documents</a></h4>
<pre><code class="language-bash"># Count all documents
dotdb count users

# Count with filter
dotdb count users '{"role": "developer"}'
</code></pre>
<h4 id="group-by-conceptual"><a class="header" href="#group-by-conceptual">Group By (Conceptual)</a></h4>
<pre><code class="language-bash"># Group by role and count
dotdb aggregate users '[
  {"$group": {"_id": "$role", "count": {"$sum": 1}}}
]'
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">[
  {"_id": "developer", "count": 15},
  {"_id": "admin", "count": 3},
  {"_id": "manager", "count": 7}
]
</code></pre>
<h3 id="statistical-operations-conceptual"><a class="header" href="#statistical-operations-conceptual">Statistical Operations (Conceptual)</a></h3>
<pre><code class="language-bash"># Average age by role
dotdb aggregate users '[
  {"$group": {
    "_id": "$role",
    "avg_age": {"$avg": "$age"},
    "min_age": {"$min": "$age"},
    "max_age": {"$max": "$age"}
  }}
]'
</code></pre>
<h2 id="performance-optimization-4"><a class="header" href="#performance-optimization-4">Performance Optimization</a></h2>
<h3 id="document-design"><a class="header" href="#document-design">Document Design</a></h3>
<h4 id="optimal-document-structure"><a class="header" href="#optimal-document-structure">Optimal Document Structure</a></h4>
<pre><code class="language-json">{
  "user_id": "user_123",
  "profile": {
    "name": "Alice Johnson",
    "email": "alice@example.com",
    "avatar_url": "https://example.com/avatar.jpg"
  },
  "settings": {
    "theme": "dark",
    "notifications": true,
    "language": "en"
  },
  "metadata": {
    "last_login": "2025-01-01T12:00:00Z",
    "login_count": 42,
    "account_type": "premium"
  }
}
</code></pre>
<p><strong>Best Practices:</strong></p>
<ul>
<li><strong>Group related fields</strong> into nested objects</li>
<li><strong>Use consistent field names</strong> across documents</li>
<li><strong>Avoid deeply nested structures</strong> (max 3-4 levels)</li>
<li><strong>Keep document size reasonable</strong> (&lt; 1MB)</li>
</ul>
<h4 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-Patterns</a></h4>
<p><strong>Avoid:</strong></p>
<pre><code class="language-json">{
  "user_name": "Alice",
  "user_email": "alice@example.com",
  "user_age": 30,
  "user_role": "developer",
  "user_department": "engineering",
  "user_manager": "Bob",
  "user_start_date": "2020-01-01"
}
</code></pre>
<p><strong>Better:</strong></p>
<pre><code class="language-json">{
  "user": {
    "name": "Alice",
    "email": "alice@example.com",
    "age": 30,
    "employment": {
      "role": "developer",
      "department": "engineering",
      "manager": "Bob",
      "start_date": "2020-01-01"
    }
  }
}
</code></pre>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<h4 id="bulk-insert"><a class="header" href="#bulk-insert">Bulk Insert</a></h4>
<pre><code class="language-bash"># Prepare batch data
cat &gt; batch_users.json &lt;&lt; EOF
[
  {"name": "User1", "email": "user1@example.com"},
  {"name": "User2", "email": "user2@example.com"},
  {"name": "User3", "email": "user3@example.com"}
]
EOF

# Bulk insert (conceptual)
dotdb bulk-insert users batch_users.json
</code></pre>
<h4 id="bulk-update"><a class="header" href="#bulk-update">Bulk Update</a></h4>
<pre><code class="language-bash"># Bulk update matching documents
dotdb bulk-update users '{"role": "intern"}' '{"$set": {"role": "junior_developer"}}'
</code></pre>
<h3 id="monitoring-and-maintenance"><a class="header" href="#monitoring-and-maintenance">Monitoring and Maintenance</a></h3>
<h4 id="collection-statistics-1"><a class="header" href="#collection-statistics-1">Collection Statistics</a></h4>
<pre><code class="language-bash">dotdb stats users
</code></pre>
<p><strong>Response:</strong></p>
<pre><code>Collection Statistics: users
Documents: 10,000
Total size: 15.2 MB
Average document size: 1.52 KB
Indices: 4 (3.1 MB)
Fragmentation: 5.2%
Last compaction: 2025-01-01T00:00:00Z
</code></pre>
<h4 id="performance-monitoring-2"><a class="header" href="#performance-monitoring-2">Performance Monitoring</a></h4>
<pre><code class="language-bash"># Monitor slow queries
dotdb slow-queries users --threshold 100ms

# Monitor index usage
dotdb index-usage users --period 24h

# Monitor collection growth
dotdb growth-stats users --period 7d
</code></pre>
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<h3 id="user-management-system-1"><a class="header" href="#user-management-system-1">User Management System</a></h3>
<pre><code class="language-bash"># Create users collection with indices
dotdb create-collection users
dotdb create-index users email_idx email --unique
dotdb create-index users role_idx role
dotdb create-index users department_idx department

# Insert users
dotdb put users '{
  "name": "Alice Johnson",
  "email": "alice@company.com",
  "role": "developer",
  "department": "engineering",
  "hire_date": "2020-01-15",
  "salary": 75000,
  "skills": ["rust", "python", "javascript"]
}'

dotdb put users '{
  "name": "Bob Smith",
  "email": "bob@company.com",
  "role": "manager",
  "department": "engineering",
  "hire_date": "2018-03-01",
  "salary": 95000,
  "skills": ["leadership", "project_management"]
}'

# Query users
dotdb find users department '"engineering"'
dotdb find users role '"developer"'
dotdb count users '{"salary": {"$gt": 80000}}'
</code></pre>
<h3 id="product-catalog-1"><a class="header" href="#product-catalog-1">Product Catalog</a></h3>
<pre><code class="language-bash"># Create products collection
dotdb create-collection products
dotdb create-index products sku_idx sku --unique
dotdb create-index products category_idx category
dotdb create-index products price_idx price

# Insert products
dotdb put products '{
  "sku": "LAPTOP-001",
  "name": "Professional Laptop",
  "category": "electronics",
  "price": 1299.99,
  "stock": 50,
  "specifications": {
    "cpu": "Intel i7",
    "ram": "16GB",
    "storage": "512GB SSD"
  },
  "tags": ["laptop", "professional", "business"]
}'

# Query products
dotdb find products category '"electronics"'
dotdb query products '{"price": {"$lt": 1000}}'
dotdb query products '{"stock": {"$gt": 0}}'
</code></pre>
<h3 id="event-logging"><a class="header" href="#event-logging">Event Logging</a></h3>
<pre><code class="language-bash"># Create events collection
dotdb create-collection events
dotdb create-index events timestamp_idx timestamp
dotdb create-index events user_id_idx user_id
dotdb create-index events event_type_idx event_type

# Log events
dotdb put events '{
  "event_type": "user_login",
  "user_id": "user_123",
  "timestamp": "2025-01-01T12:00:00Z",
  "ip_address": "192.168.1.100",
  "user_agent": "Mozilla/5.0...",
  "success": true
}'

# Query events
dotdb find events event_type '"user_login"'
dotdb query events '{"timestamp": {"$gte": "2025-01-01T00:00:00Z"}}'
dotdb count events '{"success": false}'
</code></pre>
<p>For more information about advanced DotDB features, see the <a href="dotdb/usage/advanced-features.html">Advanced Features Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-features-1"><a class="header" href="#advanced-features-1">Advanced Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-1"><a class="header" href="#api-reference-1">API Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-api"><a class="header" href="#storage-api">Storage API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-api"><a class="header" href="#state-api">State API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-standards"><a class="header" href="#code-standards">Code Standards</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-workflow-2"><a class="header" href="#development-workflow-2">Development Workflow</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>

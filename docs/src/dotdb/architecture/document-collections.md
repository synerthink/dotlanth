# Document Collections

Document collections are the primary organizational unit in DotDB. They group related documents together and provide the foundation for indexing, querying, and data management operations.

## Collection Concepts

### What is a Collection?

A collection in DotDB is similar to a table in relational databases or a collection in MongoDB. It contains a set of related JSON documents that share common characteristics or serve similar purposes.

**Key Properties:**
- **Schema-flexible**: Documents in a collection can have different structures
- **Indexed**: Collections support multiple index types for efficient queries
- **Isolated**: Collections provide logical separation of data
- **Scalable**: Collections can grow to handle large datasets

### Collection Naming

Collection names must follow specific rules:

**Valid Names:**
- Must start with a letter or underscore
- Can contain letters, numbers, underscores, and hyphens
- Case-sensitive
- Maximum length: 64 characters

**Examples:**
```
users           ✓ Valid
user_profiles   ✓ Valid
user-data       ✓ Valid
_system         ✓ Valid
123users        ✗ Invalid (starts with number)
user@data       ✗ Invalid (contains @)
```

## Collection Structure

### Physical Layout

Each collection has its own directory structure:

```
collections/
└── users/
    ├── metadata.json      # Collection metadata
    ├── data/             # Document storage
    │   ├── segment_001.db
    │   ├── segment_002.db
    │   └── ...
    ├── indices/          # Index files
    │   ├── primary.idx   # Primary key index
    │   ├── email.idx     # Secondary indices
    │   └── ...
    └── wal/              # Write-ahead log
        ├── wal_001.log
        └── ...
```

### Metadata Structure

Collection metadata is stored in `metadata.json`:

```json
{
  "name": "users",
  "created_at": "2025-01-01T00:00:00Z",
  "updated_at": "2025-01-01T12:00:00Z",
  "document_count": 1500,
  "total_size": 1048576,
  "indices": [
    {
      "name": "primary",
      "type": "btree",
      "fields": ["_id"],
      "unique": true
    },
    {
      "name": "email_idx",
      "type": "hash",
      "fields": ["email"],
      "unique": true
    }
  ],
  "settings": {
    "auto_index": true,
    "compression": "lz4",
    "segment_size": 67108864
  }
}
```

## Document Storage

### Document Format

Documents are stored as JSON with additional metadata:

```json
{
  "_id": "user_123",
  "_version": 1,
  "_created_at": "2025-01-01T00:00:00Z",
  "_updated_at": "2025-01-01T00:00:00Z",
  "name": "Alice Johnson",
  "email": "alice@example.com",
  "age": 30,
  "preferences": {
    "theme": "dark",
    "notifications": true
  }
}
```

### System Fields

DotDB automatically adds system fields to each document:

| Field | Type | Description |
|-------|------|-------------|
| `_id` | String | Unique document identifier |
| `_version` | Integer | Document version number |
| `_created_at` | Timestamp | Document creation time |
| `_updated_at` | Timestamp | Last modification time |
| `_size` | Integer | Document size in bytes |

### Document Identifiers

Document IDs can be:

- **Auto-generated**: UUIDs generated by DotDB
- **User-provided**: Custom strings provided by the application
- **Composite**: Generated from multiple fields

**Examples:**
```rust
// Auto-generated ID
put_document("users", None, document) // Returns generated ID

// User-provided ID
put_document("users", Some("user_123"), document)

// Composite ID (application logic)
let id = format!("{}_{}", user.email, user.created_at);
put_document("users", Some(&id), document)
```

## Collection Operations

### Creating Collections

Collections can be created explicitly or implicitly:

**Explicit Creation:**
```rust
// Create collection with default settings
create_collection("users")?;

// Create collection with custom settings
let settings = CollectionSettings {
    auto_index: true,
    compression: CompressionType::Lz4,
    segment_size: 64 * 1024 * 1024, // 64MB
};
create_collection_with_settings("users", settings)?;
```

**Implicit Creation:**
```rust
// Collection created automatically on first document insert
put_document("new_collection", "doc_1", document)?;
```

### Listing Collections

```rust
// Get all collection names
let collections = list_collections()?;

// Get collection metadata
let metadata = get_collection_metadata("users")?;

// Get collection statistics
let stats = get_collection_stats("users")?;
```

### Dropping Collections

```rust
// Drop collection and all its data
drop_collection("users")?;

// Drop collection with confirmation
drop_collection_confirmed("users", "users")?;
```

## Indexing

### Index Types

DotDB supports multiple index types:

#### Primary Index (B+ Tree)
- **Purpose**: Unique document identification
- **Fields**: `_id` field
- **Properties**: Always unique, automatically created

#### Secondary Indices

**Hash Index:**
```rust
create_index("users", "email_idx", IndexType::Hash, &["email"], true)?;
```
- **Use Case**: Exact-match queries
- **Performance**: O(1) lookup time
- **Limitations**: No range queries

**B+ Tree Index:**
```rust
create_index("users", "age_idx", IndexType::BTree, &["age"], false)?;
```
- **Use Case**: Range queries, sorting
- **Performance**: O(log n) lookup time
- **Features**: Supports range operations

**Composite Index:**
```rust
create_index("users", "name_age_idx", IndexType::BTree, &["name", "age"], false)?;
```
- **Use Case**: Multi-field queries
- **Performance**: Efficient for prefix queries
- **Order**: Field order matters

### Index Management

**Creating Indices:**
```rust
// Simple index
create_index("users", "email_idx", IndexType::Hash, &["email"], true)?;

// Composite index
create_index("users", "location_idx", IndexType::BTree, &["city", "state"], false)?;

// Partial index (planned feature)
create_partial_index("users", "active_users", &["status"], "status = 'active'")?;
```

**Managing Indices:**
```rust
// List indices for a collection
let indices = list_indices("users")?;

// Drop an index
drop_index("users", "email_idx")?;

// Rebuild an index
rebuild_index("users", "email_idx")?;

// Get index statistics
let stats = get_index_stats("users", "email_idx")?;
```

## Collection Settings

### Configuration Options

Collections support various configuration options:

```rust
pub struct CollectionSettings {
    pub auto_index: bool,           // Automatically create indices
    pub compression: CompressionType, // Data compression
    pub segment_size: usize,        // Segment file size
    pub cache_size: usize,          // Collection cache size
    pub sync_mode: SyncMode,        // Durability settings
    pub max_document_size: usize,   // Maximum document size
}
```

### Compression

DotDB supports multiple compression algorithms:

- **None**: No compression (fastest)
- **LZ4**: Fast compression with good ratio
- **Zstd**: Better compression ratio, slower
- **Snappy**: Google's compression algorithm

**Performance Comparison:**
```
Algorithm | Compression Ratio | Speed | CPU Usage
----------|------------------|-------|----------
None      | 1.0x            | ★★★★★ | ★☆☆☆☆
LZ4       | 2.5x            | ★★★★☆ | ★★☆☆☆
Snappy    | 2.2x            | ★★★☆☆ | ★★☆☆☆
Zstd      | 3.5x            | ★★☆☆☆ | ★★★☆☆
```

### Sync Modes

Control durability vs. performance trade-offs:

- **None**: No explicit syncing (fastest, least durable)
- **Normal**: Sync on transaction commit
- **Full**: Sync after every write (slowest, most durable)

## Collection Statistics

### Monitoring Collections

DotDB provides comprehensive collection statistics:

```rust
pub struct CollectionStats {
    pub document_count: u64,
    pub total_size: u64,
    pub average_document_size: f64,
    pub index_count: usize,
    pub index_size: u64,
    pub segment_count: usize,
    pub compression_ratio: f64,
    pub read_operations: u64,
    pub write_operations: u64,
    pub cache_hit_ratio: f64,
}
```

### Performance Metrics

**Query Performance:**
```rust
// Get query execution statistics
let query_stats = get_query_stats("users")?;
println!("Average query time: {}ms", query_stats.avg_query_time);
println!("Index usage: {}%", query_stats.index_usage_ratio);
```

**Storage Metrics:**
```rust
// Get storage utilization
let storage_stats = get_storage_stats("users")?;
println!("Storage efficiency: {}%", storage_stats.efficiency);
println!("Fragmentation: {}%", storage_stats.fragmentation);
```

## Best Practices

### Collection Design

1. **Logical Grouping**: Group related documents together
2. **Size Considerations**: Keep collections manageable (< 10M documents)
3. **Index Strategy**: Create indices for common query patterns
4. **Naming Convention**: Use consistent, descriptive names

### Performance Optimization

1. **Index Selection**: Choose appropriate index types
2. **Document Size**: Keep documents reasonably sized (< 1MB)
3. **Batch Operations**: Use bulk operations for better performance
4. **Compression**: Enable compression for large collections

### Schema Design

1. **Consistent Structure**: Maintain consistent document structure
2. **Field Naming**: Use consistent field naming conventions
3. **Nested Objects**: Limit nesting depth for better performance
4. **Array Fields**: Consider index implications for array fields

## Examples

### E-commerce Application

```rust
// Product catalog
create_collection("products")?;
create_index("products", "category_idx", IndexType::BTree, &["category"], false)?;
create_index("products", "price_idx", IndexType::BTree, &["price"], false)?;
create_index("products", "sku_idx", IndexType::Hash, &["sku"], true)?;

// User orders
create_collection("orders")?;
create_index("orders", "user_idx", IndexType::Hash, &["user_id"], false)?;
create_index("orders", "date_idx", IndexType::BTree, &["order_date"], false)?;
create_index("orders", "status_idx", IndexType::Hash, &["status"], false)?;
```

### Content Management System

```rust
// Articles
create_collection("articles")?;
create_index("articles", "author_idx", IndexType::Hash, &["author_id"], false)?;
create_index("articles", "published_idx", IndexType::BTree, &["published_at"], false)?;
create_index("articles", "category_idx", IndexType::BTree, &["category"], false)?;

// Comments
create_collection("comments")?;
create_index("comments", "article_idx", IndexType::Hash, &["article_id"], false)?;
create_index("comments", "user_idx", IndexType::Hash, &["user_id"], false)?;
```

### IoT Data Collection

```rust
// Sensor readings
create_collection("sensor_data")?;
create_index("sensor_data", "device_time_idx", IndexType::BTree, &["device_id", "timestamp"], false)?;
create_index("sensor_data", "type_idx", IndexType::Hash, &["sensor_type"], false)?;

// Device status
create_collection("devices")?;
create_index("devices", "location_idx", IndexType::BTree, &["location"], false)?;
create_index("devices", "status_idx", IndexType::Hash, &["status"], false)?;
```

## Troubleshooting

### Common Issues

1. **Collection Not Found**: Ensure collection exists before operations
2. **Index Conflicts**: Check for duplicate index names
3. **Performance Issues**: Review index usage and query patterns
4. **Storage Growth**: Monitor collection size and implement cleanup

### Diagnostic Commands

```bash
# Collection information
dotdb collections
dotdb count collection_name

# Index information
dotdb list-indices collection_name
dotdb index-stats collection_name index_name

# Performance analysis
dotdb analyze collection_name
dotdb query-plan collection_name "query"
```

For more information about working with documents, see [Document Management](../usage/document-management.md).
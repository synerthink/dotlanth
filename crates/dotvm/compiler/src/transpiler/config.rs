// Dotlanth
// Copyright (C) 2025 Synerthink

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.

// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! Configuration types and validation for the transpiler

use super::error::{TranspilationError, TranspilationResult};
use dotvm_core::bytecode::VmArchitecture;

/// Configuration for the transpilation process
#[derive(Debug, Clone)]
pub struct TranspilationConfig {
    /// Target architecture for the generated bytecode
    pub target_architecture: VmArchitecture,
    /// Whether to enable optimizations
    pub enable_optimizations: bool,
    /// Whether to preserve debug information
    pub preserve_debug_info: bool,
    /// Maximum function size before splitting
    pub max_function_size: Option<u32>,
    /// Whether to enable architecture-specific features
    pub enable_arch_features: bool,
    /// Optimization level (0-3)
    pub optimization_level: OptimizationLevel,
    /// Memory configuration
    pub memory_config: MemoryConfig,
    /// Pipeline configuration
    pub pipeline_config: PipelineConfig,
    /// Feature flags
    pub feature_flags: FeatureFlags,
}

impl Default for TranspilationConfig {
    fn default() -> Self {
        Self {
            target_architecture: VmArchitecture::Arch64,
            enable_optimizations: true,
            preserve_debug_info: false,
            max_function_size: Some(65536), // 64KB
            enable_arch_features: true,
            optimization_level: OptimizationLevel::O2,
            memory_config: MemoryConfig::default(),
            pipeline_config: PipelineConfig::default(),
            feature_flags: FeatureFlags::default(),
        }
    }
}

impl TranspilationConfig {
    /// Create a new configuration with default values
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a configuration for a specific architecture
    pub fn for_architecture(arch: VmArchitecture) -> Self {
        Self {
            target_architecture: arch,
            ..Default::default()
        }
    }

    /// Create a debug configuration
    pub fn debug() -> Self {
        Self {
            enable_optimizations: false,
            preserve_debug_info: true,
            optimization_level: OptimizationLevel::O0,
            ..Default::default()
        }
    }

    /// Create a release configuration
    pub fn release() -> Self {
        Self {
            enable_optimizations: true,
            preserve_debug_info: false,
            optimization_level: OptimizationLevel::O3,
            ..Default::default()
        }
    }

    /// Set the target architecture
    pub fn with_architecture(mut self, arch: VmArchitecture) -> Self {
        self.target_architecture = arch;
        self
    }

    /// Enable or disable optimizations
    pub fn with_optimizations(mut self, enable: bool) -> Self {
        self.enable_optimizations = enable;
        self
    }

    /// Set optimization level
    pub fn with_optimization_level(mut self, level: OptimizationLevel) -> Self {
        self.optimization_level = level;
        self.enable_optimizations = level != OptimizationLevel::O0;
        self
    }

    /// Enable or disable debug information preservation
    pub fn with_debug_info(mut self, preserve: bool) -> Self {
        self.preserve_debug_info = preserve;
        self
    }

    /// Set maximum function size
    pub fn with_max_function_size(mut self, size: Option<u32>) -> Self {
        self.max_function_size = size;
        self
    }

    /// Enable or disable architecture-specific features
    pub fn with_arch_features(mut self, enable: bool) -> Self {
        self.enable_arch_features = enable;
        self
    }

    /// Set memory configuration
    pub fn with_memory_config(mut self, config: MemoryConfig) -> Self {
        self.memory_config = config;
        self
    }

    /// Set pipeline configuration
    pub fn with_pipeline_config(mut self, config: PipelineConfig) -> Self {
        self.pipeline_config = config;
        self
    }

    /// Set feature flags
    pub fn with_feature_flags(mut self, flags: FeatureFlags) -> Self {
        self.feature_flags = flags;
        self
    }

    /// Validate the configuration
    pub fn validate(&self) -> TranspilationResult<()> {
        // Validate max function size
        if let Some(size) = self.max_function_size {
            if size == 0 {
                return Err(TranspilationError::ConfigurationValidationError {
                    field: "max_function_size".to_string(),
                    details: "Maximum function size cannot be zero".to_string(),
                });
            }
            if size > 1024 * 1024 {
                // 1MB limit
                return Err(TranspilationError::ConfigurationValidationError {
                    field: "max_function_size".to_string(),
                    details: "Maximum function size cannot exceed 1MB".to_string(),
                });
            }
        }

        // Validate memory configuration
        self.memory_config.validate()?;

        // Validate pipeline configuration
        self.pipeline_config.validate()?;

        // Validate feature compatibility with architecture
        if self.feature_flags.enable_simd && !self.target_architecture.supports_simd() {
            return Err(TranspilationError::ConfigurationValidationError {
                field: "feature_flags.enable_simd".to_string(),
                details: format!("SIMD not supported on {:?}", self.target_architecture),
            });
        }

        Ok(())
    }

    /// Check if a feature is enabled
    pub fn is_feature_enabled(&self, feature: &str) -> bool {
        match feature {
            "simd" => self.feature_flags.enable_simd,
            "threads" => self.feature_flags.enable_threads,
            "bulk_memory" => self.feature_flags.enable_bulk_memory,
            "reference_types" => self.feature_flags.enable_reference_types,
            "tail_call" => self.feature_flags.enable_tail_call,
            "multi_value" => self.feature_flags.enable_multi_value,
            _ => false,
        }
    }

    /// Get the effective optimization level
    pub fn effective_optimization_level(&self) -> OptimizationLevel {
        if self.enable_optimizations { self.optimization_level } else { OptimizationLevel::O0 }
    }
}

/// Optimization levels
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OptimizationLevel {
    /// No optimization
    O0,
    /// Basic optimization
    O1,
    /// Standard optimization
    O2,
    /// Aggressive optimization
    O3,
}

impl OptimizationLevel {
    /// Get the optimization level as a number
    pub fn as_u8(&self) -> u8 {
        match self {
            Self::O0 => 0,
            Self::O1 => 1,
            Self::O2 => 2,
            Self::O3 => 3,
        }
    }

    /// Create from a number
    pub fn from_u8(level: u8) -> Option<Self> {
        match level {
            0 => Some(Self::O0),
            1 => Some(Self::O1),
            2 => Some(Self::O2),
            3 => Some(Self::O3),
            _ => None,
        }
    }

    /// Check if this level enables a specific optimization
    pub fn enables_optimization(&self, optimization: &str) -> bool {
        match optimization {
            "constant_folding" => *self >= Self::O1,
            "dead_code_elimination" => *self >= Self::O1,
            "peephole" => *self >= Self::O1,
            "function_inlining" => *self >= Self::O2,
            "loop_optimization" => *self >= Self::O2,
            "aggressive_inlining" => *self >= Self::O3,
            "vectorization" => *self >= Self::O3,
            _ => false,
        }
    }
}

impl PartialOrd for OptimizationLevel {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for OptimizationLevel {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.as_u8().cmp(&other.as_u8())
    }
}

/// Memory configuration
#[derive(Debug, Clone)]
pub struct MemoryConfig {
    /// Default page size in bytes
    pub default_page_size: u32,
    /// Maximum memory size in bytes
    pub max_memory_size: Option<u64>,
    /// Whether to enable memory protection
    pub enable_memory_protection: bool,
    /// Memory alignment requirements
    pub memory_alignment: u32,
    /// Whether to enable memory compression
    pub enable_compression: bool,
}

impl Default for MemoryConfig {
    fn default() -> Self {
        Self {
            default_page_size: 65536,                      // 64KB (WASM standard)
            max_memory_size: Some(4 * 1024 * 1024 * 1024), // 4GB
            enable_memory_protection: true,
            memory_alignment: 8, // 8-byte alignment
            enable_compression: false,
        }
    }
}

impl MemoryConfig {
    /// Validate the memory configuration
    pub fn validate(&self) -> TranspilationResult<()> {
        if self.default_page_size == 0 || !self.default_page_size.is_power_of_two() {
            return Err(TranspilationError::ConfigurationValidationError {
                field: "memory_config.default_page_size".to_string(),
                details: "Page size must be a non-zero power of two".to_string(),
            });
        }

        if self.memory_alignment == 0 || !self.memory_alignment.is_power_of_two() {
            return Err(TranspilationError::ConfigurationValidationError {
                field: "memory_config.memory_alignment".to_string(),
                details: "Memory alignment must be a non-zero power of two".to_string(),
            });
        }

        if let Some(max_size) = self.max_memory_size {
            if max_size == 0 {
                return Err(TranspilationError::ConfigurationValidationError {
                    field: "memory_config.max_memory_size".to_string(),
                    details: "Maximum memory size cannot be zero".to_string(),
                });
            }
        }

        Ok(())
    }
}

/// Pipeline configuration
#[derive(Debug, Clone)]
pub struct PipelineConfig {
    /// Whether to enable parallel processing
    pub enable_parallel_processing: bool,
    /// Number of worker threads (None = auto-detect)
    pub worker_threads: Option<usize>,
    /// Whether to enable pipeline caching
    pub enable_caching: bool,
    /// Maximum cache size in bytes
    pub max_cache_size: Option<u64>,
    /// Pipeline timeout in seconds
    pub timeout_seconds: Option<u64>,
}

impl Default for PipelineConfig {
    fn default() -> Self {
        Self {
            enable_parallel_processing: true,
            worker_threads: None, // Auto-detect
            enable_caching: true,
            max_cache_size: Some(256 * 1024 * 1024), // 256MB
            timeout_seconds: Some(300),              // 5 minutes
        }
    }
}

impl PipelineConfig {
    /// Validate the pipeline configuration
    pub fn validate(&self) -> TranspilationResult<()> {
        if let Some(threads) = self.worker_threads {
            if threads == 0 {
                return Err(TranspilationError::ConfigurationValidationError {
                    field: "pipeline_config.worker_threads".to_string(),
                    details: "Worker thread count cannot be zero".to_string(),
                });
            }
        }

        if let Some(cache_size) = self.max_cache_size {
            if cache_size == 0 {
                return Err(TranspilationError::ConfigurationValidationError {
                    field: "pipeline_config.max_cache_size".to_string(),
                    details: "Maximum cache size cannot be zero".to_string(),
                });
            }
        }

        if let Some(timeout) = self.timeout_seconds {
            if timeout == 0 {
                return Err(TranspilationError::ConfigurationValidationError {
                    field: "pipeline_config.timeout_seconds".to_string(),
                    details: "Timeout cannot be zero".to_string(),
                });
            }
        }

        Ok(())
    }
}

/// Feature flags for enabling/disabling specific WASM features
#[derive(Debug, Clone)]
pub struct FeatureFlags {
    /// Enable SIMD instructions
    pub enable_simd: bool,
    /// Enable thread support
    pub enable_threads: bool,
    /// Enable bulk memory operations
    pub enable_bulk_memory: bool,
    /// Enable reference types
    pub enable_reference_types: bool,
    /// Enable tail call optimization
    pub enable_tail_call: bool,
    /// Enable multi-value returns
    pub enable_multi_value: bool,
    /// Enable exception handling
    pub enable_exceptions: bool,
    /// Enable memory64
    pub enable_memory64: bool,
}

impl Default for FeatureFlags {
    fn default() -> Self {
        Self {
            enable_simd: true,
            enable_threads: false, // Disabled by default due to complexity
            enable_bulk_memory: true,
            enable_reference_types: true,
            enable_tail_call: true,
            enable_multi_value: true,
            enable_exceptions: false, // Experimental
            enable_memory64: false,   // Experimental
        }
    }
}

impl FeatureFlags {
    /// Create feature flags with all features disabled
    pub fn none() -> Self {
        Self {
            enable_simd: false,
            enable_threads: false,
            enable_bulk_memory: false,
            enable_reference_types: false,
            enable_tail_call: false,
            enable_multi_value: false,
            enable_exceptions: false,
            enable_memory64: false,
        }
    }

    /// Create feature flags with all stable features enabled
    pub fn stable() -> Self {
        Self {
            enable_simd: true,
            enable_threads: false,
            enable_bulk_memory: true,
            enable_reference_types: true,
            enable_tail_call: true,
            enable_multi_value: true,
            enable_exceptions: false,
            enable_memory64: false,
        }
    }

    /// Create feature flags with all features enabled (including experimental)
    pub fn all() -> Self {
        Self {
            enable_simd: true,
            enable_threads: true,
            enable_bulk_memory: true,
            enable_reference_types: true,
            enable_tail_call: true,
            enable_multi_value: true,
            enable_exceptions: true,
            enable_memory64: true,
        }
    }
}

/// Configuration builder for fluent API
pub struct TranspilationConfigBuilder {
    config: TranspilationConfig,
}

impl TranspilationConfigBuilder {
    /// Create a new builder
    pub fn new() -> Self {
        Self {
            config: TranspilationConfig::default(),
        }
    }

    /// Set target architecture
    pub fn architecture(mut self, arch: VmArchitecture) -> Self {
        self.config.target_architecture = arch;
        self
    }

    /// Set optimization level
    pub fn optimization_level(mut self, level: OptimizationLevel) -> Self {
        self.config.optimization_level = level;
        self.config.enable_optimizations = level != OptimizationLevel::O0;
        self
    }

    /// Enable debug information
    pub fn debug_info(mut self, enable: bool) -> Self {
        self.config.preserve_debug_info = enable;
        self
    }

    /// Set maximum function size
    pub fn max_function_size(mut self, size: u32) -> Self {
        self.config.max_function_size = Some(size);
        self
    }

    /// Set feature flags
    pub fn features(mut self, flags: FeatureFlags) -> Self {
        self.config.feature_flags = flags;
        self
    }

    /// Build the configuration
    pub fn build(self) -> TranspilationResult<TranspilationConfig> {
        self.config.validate()?;
        Ok(self.config)
    }
}

impl Default for TranspilationConfigBuilder {
    fn default() -> Self {
        Self::new()
    }
}

// Extension trait for VmArchitecture to add feature support queries
trait VmArchitectureExt {
    fn supports_simd(&self) -> bool;
    fn supports_threads(&self) -> bool;
    fn supports_memory64(&self) -> bool;
}

impl VmArchitectureExt for VmArchitecture {
    fn supports_simd(&self) -> bool {
        match self {
            VmArchitecture::Arch32 => false,
            VmArchitecture::Arch64 => true,
            VmArchitecture::Arch128 => true,
            VmArchitecture::Arch256 => true,
            VmArchitecture::Arch512 => true,
        }
    }

    fn supports_threads(&self) -> bool {
        match self {
            VmArchitecture::Arch32 => false,
            VmArchitecture::Arch64 => true,
            VmArchitecture::Arch128 => true,
            VmArchitecture::Arch256 => true,
            VmArchitecture::Arch512 => true,
        }
    }

    fn supports_memory64(&self) -> bool {
        match self {
            VmArchitecture::Arch32 => false,
            VmArchitecture::Arch64 => false,
            VmArchitecture::Arch128 => true,
            VmArchitecture::Arch256 => true,
            VmArchitecture::Arch512 => true,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = TranspilationConfig::default();
        assert_eq!(config.target_architecture, VmArchitecture::Arch64);
        assert!(config.enable_optimizations);
        assert!(!config.preserve_debug_info);
        assert_eq!(config.optimization_level, OptimizationLevel::O2);
    }

    #[test]
    fn test_config_validation() {
        let mut config = TranspilationConfig::default();
        config.max_function_size = Some(0);
        assert!(config.validate().is_err());

        config.max_function_size = Some(1024);
        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_optimization_levels() {
        assert!(OptimizationLevel::O2 > OptimizationLevel::O1);
        assert!(OptimizationLevel::O1.enables_optimization("constant_folding"));
        assert!(!OptimizationLevel::O0.enables_optimization("constant_folding"));
    }

    #[test]
    fn test_config_builder() {
        let config = TranspilationConfigBuilder::new()
            .architecture(VmArchitecture::Arch128)
            .optimization_level(OptimizationLevel::O3)
            .debug_info(true)
            .build()
            .unwrap();

        assert_eq!(config.target_architecture, VmArchitecture::Arch128);
        assert_eq!(config.optimization_level, OptimizationLevel::O3);
        assert!(config.preserve_debug_info);
    }
}

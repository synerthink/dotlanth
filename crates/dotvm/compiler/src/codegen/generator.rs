// Dotlanth
// Copyright (C) 2025 Synerthink

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.

// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! Main bytecode generator orchestrating all generation phases

use crate::codegen::core::{context::GenerationContext, generator::BytecodeGenerator as BytecodeGeneratorTrait};
use crate::codegen::{
    config::BytecodeGenerationConfig,
    error::{BytecodeGenerationError, BytecodeResult},
    sections::{
        CodeGenerator, DataGenerator, DebugInfo, DebugInfoGenerator, ExportTable, ExportTableGenerator, FunctionTable, FunctionTableGenerator, HeaderGenerator, ImportTable, ImportTableGenerator,
    },
    writers::BytecodeWriter,
};
use crate::transpiler::types::TranspiledModule;
use std::time::Instant;

/// Statistics about the generation process
#[derive(Debug, Default)]
pub struct GenerationStats {
    pub header_size: usize,
    pub function_count: u32,
    pub code_size: usize,
    pub data_size: usize,
    pub export_count: u32,
    pub import_count: u32,
    pub optimizations_applied: u32,
    pub generation_time: std::time::Duration,
}

/// Complete generated bytecode with metadata
#[derive(Debug)]
pub struct GeneratedBytecode {
    pub bytecode: Vec<u8>,
    pub function_table: FunctionTable,
    pub export_table: ExportTable,
    pub import_table: ImportTable,
    pub debug_info: DebugInfo,
    pub stats: GenerationStats,
}

/// Main bytecode generator that orchestrates the entire generation process
/// Top-level DotVM bytecode generator orchestrating phases
pub struct BytecodeGenerator {
    config: BytecodeGenerationConfig,
    context: GenerationContext,
    writer: BytecodeWriter,
    code_generator: CodeGenerator,
}

impl BytecodeGenerator {
    /// Create a new bytecode generator with the given configuration
    pub fn new(config: BytecodeGenerationConfig) -> BytecodeResult<Self> {
        // Validate configuration
        config.validate().map_err(BytecodeGenerationError::ConfigurationError)?;

        let writer = if let Some(max_size) = config.max_bytecode_size {
            BytecodeWriter::with_max_size(max_size)
        } else {
            BytecodeWriter::new()
        };

        Ok(Self {
            config,
            context: GenerationContext::new(),
            writer,
            code_generator: CodeGenerator::new(),
        })
    }

    /// Generate DotVM bytecode from a transpiled module
    pub fn generate(&mut self, module: &TranspiledModule) -> BytecodeResult<GeneratedBytecode> {
        let start_time = Instant::now();
        let mut stats = GenerationStats::default();

        // Clear previous state
        self.reset();

        // Phase 1: Generate header
        self.generate_header_phase(module, &mut stats)?;

        // Phase 2: Generate function table
        let function_table = self.generate_function_table_phase(module, &mut stats)?;

        // Phase 3: Generate code section
        self.generate_code_phase(module, &mut stats)?;

        // Phase 4: Generate data section
        self.generate_data_phase(module, &mut stats)?;

        // Phase 5: Generate export/import tables
        let (export_table, import_table) = self.generate_tables_phase(module, &function_table, &mut stats)?;

        // Phase 6: Generate debug information
        let debug_info = self.generate_debug_phase(module, &mut stats)?;

        // Phase 7: Apply optimizations
        if self.config.enable_optimizations {
            self.optimize_phase(&mut stats)?;
        }

        // Phase 8: Finalize bytecode
        let bytecode = self.finalize_phase(&mut stats)?;

        stats.generation_time = start_time.elapsed();

        Ok(GeneratedBytecode {
            bytecode,
            function_table,
            export_table,
            import_table,
            debug_info,
            stats,
        })
    }

    /// Reset the generator state
    fn reset(&mut self) {
        self.writer.clear();
        self.code_generator = CodeGenerator::new();
    }

    /// Phase 1: Generate header section
    fn generate_header_phase(&mut self, module: &TranspiledModule, stats: &mut GenerationStats) -> BytecodeResult<()> {
        let start_size = self.writer.size();

        HeaderGenerator::generate(&mut self.writer, &module.header)?;

        stats.header_size = self.writer.size() - start_size;
        Ok(())
    }

    /// Phase 2: Generate function table section
    fn generate_function_table_phase(&mut self, module: &TranspiledModule, stats: &mut GenerationStats) -> BytecodeResult<FunctionTable> {
        let function_table = FunctionTableGenerator::generate(&mut self.writer, &module.functions)?;
        stats.function_count = function_table.entries.len() as u32;
        Ok(function_table)
    }

    /// Phase 3: Generate code section
    fn generate_code_phase(&mut self, module: &TranspiledModule, stats: &mut GenerationStats) -> BytecodeResult<()> {
        let start_size = self.writer.size();

        self.code_generator.generate(&mut self.writer, &module.functions)?;

        stats.code_size = self.writer.size() - start_size;
        Ok(())
    }

    /// Phase 4: Generate data section
    fn generate_data_phase(&mut self, module: &TranspiledModule, stats: &mut GenerationStats) -> BytecodeResult<()> {
        let start_size = self.writer.size();

        DataGenerator::generate(&mut self.writer, module)?;

        stats.data_size = self.writer.size() - start_size;
        Ok(())
    }

    /// Phase 5: Generate export and import tables
    fn generate_tables_phase(&mut self, module: &TranspiledModule, function_table: &FunctionTable, stats: &mut GenerationStats) -> BytecodeResult<(ExportTable, ImportTable)> {
        let export_table = ExportTableGenerator::generate(&mut self.writer, &module.exports, function_table)?;
        stats.export_count = export_table.entries.len() as u32;

        let import_table = ImportTableGenerator::generate(&mut self.writer, &module.imports)?;
        stats.import_count = import_table.entries.len() as u32;

        Ok((export_table, import_table))
    }

    /// Phase 6: Generate debug information
    fn generate_debug_phase(&mut self, module: &TranspiledModule, _stats: &mut GenerationStats) -> BytecodeResult<DebugInfo> {
        DebugInfoGenerator::generate(&mut self.writer, &module.functions, self.config.include_debug_info)
    }

    /// Phase 7: Apply optimizations
    fn optimize_phase(&mut self, stats: &mut GenerationStats) -> BytecodeResult<()> {
        if !self.config.enable_optimizations {
            return Ok(());
        }

        // Note: Optimization is now handled by the separate optimizer module at the compiler level
        let optimizations_applied = 0; // No optimizations applied in codegen

        stats.optimizations_applied = optimizations_applied;
        Ok(())
    }

    /// Phase 8: Finalize bytecode
    fn finalize_phase(&mut self, _stats: &mut GenerationStats) -> BytecodeResult<Vec<u8>> {
        let mut bytecode = self.writer.buffer().to_vec();

        // Apply compression if enabled
        if self.config.enable_compression {
            bytecode = self.compress_bytecode(bytecode)?;
        }

        Ok(bytecode)
    }

    /// Compress bytecode if compression is enabled
    fn compress_bytecode(&self, bytecode: Vec<u8>) -> BytecodeResult<Vec<u8>> {
        // TODO: Implement compression
        // For now, return uncompressed bytecode
        Ok(bytecode)
    }

    /// Get the current configuration
    pub fn config(&self) -> &BytecodeGenerationConfig {
        &self.config
    }

    /// Update the configuration
    pub fn set_config(&mut self, config: BytecodeGenerationConfig) -> BytecodeResult<()> {
        config.validate().map_err(BytecodeGenerationError::ConfigurationError)?;
        self.config = config;
        Ok(())
    }
}

/// Type alias for backward compatibility
pub type DotVMGenerator = BytecodeGenerator;

impl DotVMGenerator {
    /// Create a new DotVM generator with default configuration for the given architecture
    pub fn with_architecture(target_arch: dotvm_core::bytecode::VmArchitecture) -> BytecodeResult<Self> {
        let config = BytecodeGenerationConfig::for_architecture(target_arch);
        Self::new(config)
    }

    /// Generate bytecode from a transpiled module (convenience method)
    pub fn generate_bytecode(&mut self, module: &TranspiledModule) -> BytecodeResult<Vec<u8>> {
        let generated = self.generate(module)?;
        Ok(generated.bytecode)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::transpiler::types::TranspiledFunction;
    use dotvm_core::bytecode::{BytecodeHeader, VmArchitecture};

    #[test]
    fn test_generator_creation() {
        let config = BytecodeGenerationConfig::default();
        let generator = BytecodeGenerator::new(config);
        assert!(generator.is_ok());
    }

    #[test]
    fn test_invalid_config() {
        let mut config = BytecodeGenerationConfig::default();
        config.optimization_level = 10; // Invalid

        let result = BytecodeGenerator::new(config);
        assert!(result.is_err());
    }

    #[test]
    fn test_basic_generation() {
        let config = BytecodeGenerationConfig::default();
        let mut generator = BytecodeGenerator::new(config).unwrap();

        let module = TranspiledModule {
            header: BytecodeHeader::new(VmArchitecture::Arch64),
            functions: vec![TranspiledFunction {
                name: "main".to_string(),
                instructions: vec![],
                param_count: 0,
                local_count: 0,
                is_exported: true,
                debug_info: None,
                metadata: crate::transpiler::types::function::FunctionMetadata::default(),
            }],
            globals: vec![],
            memory_layout: crate::transpiler::types::variables::MemoryLayout {
                initial_pages: 1,
                maximum_pages: None,
                page_size: 65536,
                segments: Vec::new(),
                protection: crate::transpiler::types::variables::MemoryProtection::default(),
            },
            exports: vec![],
            imports: vec![],
            metadata: crate::transpiler::types::module::ModuleMetadata::default(),
        };

        let result = generator.generate(&module);
        assert!(result.is_ok());

        let generated = result.unwrap();
        assert!(!generated.bytecode.is_empty());
        assert_eq!(generated.function_table.entries.len(), 1);
    }

    #[test]
    fn test_backward_compatibility() {
        let generator = DotVMGenerator::with_architecture(VmArchitecture::Arch64);
        assert!(generator.is_ok());
    }
}
